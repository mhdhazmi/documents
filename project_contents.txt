
// File Path: .cursor/mcp.json

{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp@latest"]
    },
    "convex": {
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    },
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    "sequential-thinking": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"]
    },
    "shadcn": {
      "command": "npx",
      "args": ["-y", "shadcn@canary", "registry:mcp"],
      "env": {
        "REGISTRY_URL": "https://animate-ui.com/r/registry.json"
      }
    }
  }
}



// File Path: .vscode/settings.json

{
    "postman.settings.dotenv-detection-notification-visibility": false
}


// File Path: components.json

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


// File Path: convex/api.ts

import { httpAction } from "./_generated/server";
import { Id } from "./_generated/dataModel";
import { api, internal } from "./_generated/api";
import { cleanTextWithOpenAI } from "./utils/cleaner";
import { readableStreamFromIterable } from "./utils/stream";

// Centralized CORS headers function to ensure consistency
const getCorsHeaders = (request: Request): Record<string, string> => {
  // Get the origin from the request or fall back to configured origin
  const requestOrigin = request.headers.get("Origin");
  
  // Determine which origin to allow
  // If the origin is from our allowed domains, return that specific origin
  // This is more secure than using a wildcard
  const allowedOrigins = [
    "http://localhost:3000",
    
    "http://localhost:3001",           // Local development
    "https://your-production-domain.com", // Production
    process.env.CLIENT_ORIGIN || ""    // Environment variable if set
  ].filter(Boolean);
  
  // Determine which origin to use in the response
  let originToAllow = "*"; // Default fallback (less secure)
  
  if (requestOrigin) {
    if (allowedOrigins.includes(requestOrigin)) {
      // If it's in our allowed list, echo it back
      originToAllow = requestOrigin;
    } else if (requestOrigin.endsWith(".vercel.app")) {
      // Preview deployments (optional)
      originToAllow = requestOrigin;
    }
  }
  
  return {
    "Access-Control-Allow-Origin": originToAllow,
    "Access-Control-Allow-Methods": "POST, OPTIONS, GET",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Requested-With",
    "Access-Control-Max-Age": "86400", // 24 hours
    "Vary": "Origin" // Important when using dynamic origins
  };
};

export const cleanHandler = httpAction(async (ctx, req) => {
  // Get CORS headers for this request
  const corsHeaders = getCorsHeaders(req);
  
  // Handle preflight OPTIONS request
  if (req.method === "OPTIONS") {
    return new Response(null, { 
      status: 204, 
      headers: corsHeaders 
    });
  }

  // Handle actual request
  try {
    if (req.method !== "POST") {
      return new Response("Method not allowed", { 
        status: 405, 
        headers: corsHeaders 
      });
    }
    
    // Parse request body
    const body = await req.json().catch(err => {
      console.error("Failed to parse request body", err);
      throw new Error("Invalid JSON in request body");
    });
    
    const { pdfId, source } = body as { pdfId: Id<"pdfs">; source: "gemini" | "replicate" };
    
    if (!pdfId || !source) {
      return new Response("Missing required fields: pdfId and source", {
        status: 400,
        headers: corsHeaders
      });
    }
    
    console.log("Processing request for pdfId:", pdfId, "source:", source);
    
    // Check if PDF exists
    const pdf = await ctx.runQuery(api.pdf.queries.getPdf, { pdfId });
    if (!pdf) {
      return new Response("PDF not found in database", { 
        status: 404, 
        headers: corsHeaders 
      });
    }
    
    // Get OCR status
    const [geminiId] = await ctx.runQuery(api.ocr.gemini.queries.getOcrByPdfId, { pdfId });
    const [replicateId] = await ctx.runQuery(api.ocr.replicate.queries.getOcrByPdfId, { pdfId });
    const embeddingRecord = await ctx.runQuery(internal.ingest.ingest.getEmbedding, { pdfId });
    
    // Update status to "started"
    await ctx.runMutation(internal.ocr.openai.mutations.updateCleanedStatus, { 
      pdfId, 
      source, 
      cleaningStatus: "started", 
      cleanedText: "" 
    });
    
    // Get text to clean based on source
    let text;
    if (source === "gemini") {
      if (geminiId?.ocrStatus !== "completed") {
        return new Response("Gemini OCR not completed", { 
          status: 400, 
          headers: corsHeaders 
        });
      }
      const geminiResults = await ctx.runQuery(api.ocr.gemini.queries.getOcrByPdfId, { pdfId });
      text = geminiResults?.[0]?.extractedText || "";
    } else if (source === "replicate") {
      if (replicateId?.ocrStatus !== "completed") {
        return new Response("Replicate OCR not completed", { 
          status: 400, 
          headers: corsHeaders 
        });
      }
      const replicateResults = await ctx.runQuery(api.ocr.replicate.queries.getOcrByPdfId, { pdfId });
      text = replicateResults?.[0]?.extractedText || "";
    } else {
      return new Response(`Invalid source: ${source}`, { 
        status: 400, 
        headers: corsHeaders 
      });
    }
    
    if (!text || text.trim() === "") {
      return new Response("No text found to clean", { 
        status: 400, 
        headers: corsHeaders 
      });
    }
    
    // Set up streaming response
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    const encoder = new TextEncoder();
    
    // Process in background
    void (async () => {
      try {
        let fullText = "";
        
        // Use the new cleanTextWithOpenAI utility
        const generator = cleanTextWithOpenAI(text);
        for await (const chunk of generator) {
          await writer.write(encoder.encode(chunk));
          fullText += chunk;
        }
        
        // Get the final result from the generator
        const result = await generator.next();
        if (result.done && result.value) {
          fullText = result.value;
        }
        
        // Save completed result
        await ctx.runMutation(internal.ocr.openai.mutations.saveCleanedResults, {
          pdfId,
          source,
          cleanedText: fullText,
          cleaningStatus: "completed"
        });
        
        // Create embedding if needed
        if (source === "gemini" && !embeddingRecord) {
          await ctx.runAction(api.ingest.ingest.chunkAndEmbed, { pdfId });
        }
      } catch (error) {
        console.error("Error in streaming process:", error);
        // Can't update response headers at this point
      } finally {
        await writer.close();
      }
    })();
    
    // Return streaming response with CORS headers
    return new Response(readable, {
      headers: {
        "Content-Type": "text/plain; charset=utf-8",
        ...corsHeaders
      }
    });
    
  } catch (error) {
    console.error("Error in clean handler:", error);
    return new Response(
      JSON.stringify({ 
        error: true, 
        message: error instanceof Error ? error.message : String(error) 
      }), 
      { 
        status: 500, 
        headers: {
          "Content-Type": "application/json",
          ...corsHeaders
        } 
      }
    );
  }
});

// convex/http.ts (update the cleanPageHandler)
export const cleanPageHandler = httpAction(async (ctx, req) => {
  // Get CORS headers for this request
  const corsHeaders = getCorsHeaders(req);
  
  // Handle preflight OPTIONS request
  if (req.method === "OPTIONS") {
    return new Response(null, { 
      status: 204, 
      headers: corsHeaders 
    });
  }

  // Handle actual request
  try {
    if (req.method !== "POST") {
      return new Response("Method not allowed", { 
        status: 405, 
        headers: corsHeaders 
      });
    }
    
    // Parse request body
    const body = await req.json().catch(err => {
      console.error("Failed to parse request body", err);
      throw new Error("Invalid JSON in request body");
    });
    
    const { pageId, source } = body as { pageId: Id<"pages">; source: "gemini" | "replicate" };
    
    if (!pageId || !source) {
      return new Response("Missing required fields: pageId and source", {
        status: 400,
        headers: corsHeaders
      });
    }
    
    // Check idempotency first
    const status = await ctx.runMutation(internal.ocr.openai.mutations.startPageCleaning, { 
      pageId, 
      source 
    });
    
    if (status === "completed") {
      const cleaned = await ctx.runQuery(
        api.ocr.openai.queries.getPageCleanedResults,
        { pageId, source }
      );

      const text = cleaned?.cleanedText ?? "";

      if (text.trim() === "") {
        // Nothing to stream ‚Äì tell the client gracefully.
        return new Response(null, { status: 204, headers: corsHeaders });
      }

      return new Response(text, {
        status: 200,
        headers: {
          "Content-Type": "text/plain; charset=utf-8",
          ...corsHeaders,
        },
      });
    }
    
    console.log("Processing request for pageId:", pageId, "source:", source);
    
    // Check if page exists
    const page = await ctx.runQuery(api.pdf.queries.getPdfPage, { pageId });
    if (!page) {
      return new Response("Page not found in database", { 
        status: 404, 
        headers: corsHeaders 
      });
    }
    
    // Get OCR results based on source
    let ocrResults;
    if (source === "gemini") {
      ocrResults = await ctx.runQuery(api.ocr.gemini.queries.getPageOcrResults, { pageId });
    } else if (source === "replicate") {
      ocrResults = await ctx.runQuery(api.ocr.replicate.queries.getPageOcrResults, { pageId });
    } else {
      return new Response(`Invalid source: ${source}`, { 
        status: 400, 
        headers: corsHeaders 
      });
    }
    
    if (!ocrResults?.ocrResults || ocrResults.ocrResults.ocrStatus !== "completed") {
      return new Response(`${source} OCR not completed for this page`, { 
        status: 400, 
        headers: corsHeaders 
      });
    }
    
    const text = ocrResults.ocrResults.extractedText || "";
    if (!text || text.trim() === "") {
      return new Response("No text found to clean", { 
        status: 400, 
        headers: corsHeaders 
      });
    }
    
    // Set up streaming response
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    const encoder = new TextEncoder();
    
    // Process in background
    void (async () => {
      try {
        let fullText = "";
        
        // Use the new cleanTextWithOpenAI utility
        const generator = cleanTextWithOpenAI(text);
        for await (const chunk of generator) {
          await writer.write(encoder.encode(chunk));
          fullText += chunk;
        }
        
        // Get the final result from the generator
        const result = await generator.next();
        if (result.done && result.value) {
          fullText = result.value;
        }
        
        // Save completed result
        await ctx.runMutation(internal.ocr.openai.mutations.savePageCleanedResults, {
          pageId,
          source,
          cleanedText: fullText,
          cleaningStatus: "completed"
        });
      } catch (error) {
        console.error("Error in streaming process:", error);
        // Can't update response headers at this point
      } finally {
        await writer.close();
      }
    })();
    
    // Return streaming response with CORS headers
    return new Response(readable, {
      headers: {
        "Content-Type": "text/plain; charset=utf-8",
        ...corsHeaders
      }
    });
    
  } catch (error) {
    console.error("Error in cleanPage handler:", error);
    return new Response(
      JSON.stringify({ 
        error: true, 
        message: error instanceof Error ? error.message : String(error) 
      }), 
      { 
        status: 500, 
        headers: {
          "Content-Type": "application/json",
          ...corsHeaders
        } 
      }
    );
  }
});


// File Path: convex/concatenate/actions.ts

// convex/concatenate/actions.ts
import { internalAction } from "../_generated/server";
import { internal } from "../_generated/api";
import { v } from "convex/values";


export const recheckConcatenation = internalAction({
  args: {
    pdfId: v.id("pdfs"),
    preferredSource: v.optional(v.union(v.literal("gemini"), v.literal("replicate"))),
    retryCount: v.number(),
  },
  handler: async (ctx, args) => {
    try {
      // Restart the concatenation workflow with updated retry count
      await ctx.runMutation(internal.workflow.concatenateWorkflow.startConcatenateWorkflow, args);
      
      return {
        success: true,
        message: `Restarted concatenation workflow for PDF ${args.pdfId} (retry ${args.retryCount})`,
      };
    } catch (error) {
      console.error(`Error restarting concatenation workflow for PDF ${args.pdfId}:`, error);
      throw error;
    }
  },
});


// File Path: convex/concatenate/mutations.ts

// convex/concatenate/mutations.ts
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";

export const saveConcatenatedText = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
    text: v.string(),
  },
  handler: async (ctx, args) => {
    // Check if we already have concatenated results for this PDF and source
    const existing = await ctx.db
      .query("openaiOcrResults")
      .withIndex("by_pdf_id", (q) => q.eq("pdfId", args.pdfId))
      .filter((q) => q.eq(q.field("source"), args.source))
      .first();
    
    if (existing) {
      // Update existing record
      await ctx.db.patch(existing._id, {
        cleanedText: args.text,
        cleaningStatus: "completed",
        processedAt: Date.now(),
      });
    } else {
      // Create new record
      await ctx.db.insert("openaiOcrResults", {
        pdfId: args.pdfId,
        cleanedText: args.text,
        cleaningStatus: "completed",
        processedAt: Date.now(),
        source: args.source,
      });
    }
    
    // Update the PDF status to indicate processing is complete
    await ctx.db.patch(args.pdfId, {
      status: "processed",
    });
  },
});


// File Path: convex/concatenate/queries.ts

// convex/concatenate/queries.ts
import { internalQuery } from "../_generated/server";
import { v } from "convex/values";

export const areAllPagesComplete = internalQuery({
  args: {
    pdfId: v.id("pdfs"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, args) => {
    // 1. Get all pages for this PDF
    const pages = await ctx.db
      .query("pages")
      .withIndex("byPdfId", (q) => q.eq("pdfId", args.pdfId))
      .collect();

    if (pages.length === 0) {
      return false;
    }

    // 2. Check if every page has cleaned results for the specified source
    for (const page of pages) {
      const cleaned = await ctx.db
        .query("openaiCleanedPage")
        .withIndex("by_page_id", (q) => q.eq("pageId", page._id))
        .filter(
          (q) =>
            q.eq(q.field("source"), args.source) &&
            q.eq(q.field("cleaningStatus"), "completed")
        )
        .first();

      // If any page doesn't have complete cleaned results, return false
      if (!cleaned) {
        return false;
      }
    }

    // All pages have completed cleaned results
    return true;
  },
});

export const getConcatenatedText = internalQuery({
  args: {
    pdfId: v.id("pdfs"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, args) => {
    // 1. Get all pages for this PDF in order
    const pages = await ctx.db
      .query("pages")
      .withIndex("byPdfIdAndPageNumber", (q) => q.eq("pdfId", args.pdfId))
      .collect();

    if (pages.length === 0) {
      return "";
    }

    // 2. Get the cleaned text for each page in order
    const pageTexts: string[] = [];

    for (const page of pages) {
      const cleaned = await ctx.db
        .query("openaiCleanedPage")
        .withIndex("by_page_id", (q) => q.eq("pageId", page._id))
        .filter(
          (q) =>
            q.eq(q.field("source"), args.source) &&
            q.eq(q.field("cleaningStatus"), "completed")
        )
        .first();

      if (cleaned?.cleanedText) {
        pageTexts.push(
          `--- PAGE ${page.pageNumber} ---\n${cleaned.cleanedText}`
        );
      } else {
        pageTexts.push(`--- PAGE ${page.pageNumber} ---\n[No text available]`);
      }
    }

    // 3. Join all page texts with double newlines
    return pageTexts.join("\n\n");
  },
});



// File Path: convex/config.ts

// convex/config.ts
// Configuration file for OCR and other services

// Replicate OCR Configuration
export const replicate = {
    model: "lucataco/olmocr-7b",
    modelVersion: "d96720d5a835ed7b48f2951a5e5f4e247ed724f6fd96c6b96b5c7234f635065f",
    batchSize: 7,
    maxRetries: 3,
    retryDelayMs: 10000, // default retry delay in ms if not specified by API
    timeoutMs: 5000, // timeout between polling requests
    temperature: 0.1, // Add this parameter to reduce randomness
};

// Gemini OCR Configuration
export const gemini = {
    model: "gemini-2.5-pro-exp-03-25",
    fileProcessingPollingIntervalMs: 1000,
    prompt: `üéØ Objective
Perform high-accuracy OCR (Optical Character Recognition) on Arabic-language documents. The input may be a scanned document, photographed text, or a PDF containing Arabic script.

üìå Instructions
Please follow these guidelines strictly:

Language: Arabic only. Do not detect or output any other language.

Direction: Read text from right to left.

Tags: üö´ Do not include any XML, HTML, or formatting tags in the output. Only raw text is required.

Diacritics: Preserve Arabic diacritics (like Ÿé Ÿè Ÿê Ÿë ) if they exist in the original image.

Punctuation & Symbols: Preserve punctuation marks (ÿå ÿõ ÿü .) and numerals as they appear.

Character Forms: Recognize context-based Arabic letter shapes (isolated, initial, medial, final).

Ligatures: Correctly handle common ligatures such as "ŸÑÿß" and words where characters are joined naturally.

Line and Paragraph Structure:

Maintain logical order and spacing of lines.

Avoid inserting artificial line breaks unless they exist in the original.

Mixed Content:

If non-Arabic text (e.g. English words, numbers) is present, retain it only if part of the original content.

Preserve inline structure (e.g. English terms within Arabic sentences).`
};

// OpenAI Configuration
export const openai = {
    model: "gpt-4o-mini",
    streamingModel: "gpt-4o-mini", // Used in API streaming endpoints
    temperature: 0.1,
    systemPrompt: `
    üßπ Final Cleanup Model Prompt (Arabic Text Post-OCR Correction)
üéØ Objective
Refine and correct Arabic text that was previously extracted via OCR. The goal is to clean up common OCR mistakes such as incorrect characters or distorted words that do not fit the context.

üìå Instructions
Carefully revise the input text by applying the following rules:

Language: Arabic only. Ignore any embedded formatting or tagging from OCR output.

Contextual Corrections:

Fix words that contain incorrect characters and result in a loss of meaning.

Use the surrounding context of each word to infer the correct spelling or structure.

Spelling and Grammar:

Apply standard Arabic grammar and spelling rules.

Correct misspellings caused by character swaps or OCR noise.

Do Not Add Content:

Do not insert new words that were not present or implied in the original.

Only correct what appears to be a likely OCR mistake.

Diacritics:

Preserve diacritics if present, but it's okay to omit them if missing.

Structure Preservation:

Maintain paragraph and sentence structure as-is from the OCR output.

Avoid breaking up lines or rearranging the order of words unless absolutely necessary for clarity.

make sure the returned text is RTL
`,
    userPromptPrefix: "Clean and reformat the following OCR text:\n\n"
};

// General OCR Configuration
export const ocr = {
    performOcrPrompt: "Perform OCR on the following document, clean the text and translate it to both English and Arabic\ntext = {'Arabic': string, 'English': string}\nReturn: Array<text>",
    statusTypes: {
        processing: "processing",
        success: "success",
        failed: "failed"
    }
}; 

// Embedding configuration
export const embedding = {
    model: 'text-embedding-3-small',
    dimensions: 1536,
    chunking: {
        chunkSize: 8000,
        chunkOverlap: 500
    }
};


// File Path: convex/CONFIG_README.md

# OCR Configuration System

This document explains the configuration system for the OCR functionality in the Convex application.

## Overview

All configuration values for the OCR system have been centralized in the `convex/config.ts` file. This allows for easy customization of various aspects of the OCR functionality without having to modify the code directly.

## Configuration Structure

The configuration is organized into several sections:

### Replicate OCR Configuration

```typescript
export const replicate = {
  model: "lucataco/olmocr-7b",
  modelVersion: "d96720d5a835ed7b48f2951a5e5f4e247ed724f6fd96c6b96b5c7234f635065f",
  batchSize: 5,
  maxRetries: 3,
  retryDelayMs: 10000, // default retry delay in ms if not specified by API
  timeoutMs: 5000, // timeout between polling requests
};
```

- `model`: The Replicate model to use for OCR
- `modelVersion`: The specific model version to use
- `batchSize`: Number of pages to process in parallel
- `maxRetries`: Maximum number of retry attempts for failed API calls
- `retryDelayMs`: Default delay between retries in milliseconds
- `timeoutMs`: Timeout for polling requests

### Gemini OCR Configuration

```typescript
export const gemini = {
  model: "gemini-1.5-flash",
  fileProcessingPollingIntervalMs: 5000,
  prompt: "Perform OCR on the PDF document and extract the text content. Return the text content in a structured format, including headers, paragraphs, and tables. Do not change the original language of the document."
};
```

- `model`: The Gemini model to use for OCR
- `fileProcessingPollingIntervalMs`: Polling interval when waiting for file processing
- `prompt`: The prompt to send to Gemini for OCR extraction

### OpenAI Configuration

```typescript
export const openai = {
  model: "gpt-4o",
  temperature: 0.3,
  systemPrompt: "You are an expert at cleaning and formatting OCR text. Your job is to take raw OCR output and clean it up - fix formatting issues, correct obvious OCR errors, properly structure paragraphs, tables, and sections. Preserve all original content but make it more readable.",
  userPromptPrefix: "Clean and reformat the following OCR text:\n\n"
};
```

- `model`: The OpenAI model to use for text cleanup
- `temperature`: The temperature parameter for the API call
- `systemPrompt`: The system prompt to send to OpenAI
- `userPromptPrefix`: The prefix to add to the user prompt

### General OCR Configuration

```typescript
export const ocr = {
  performOcrPrompt: "Perform OCR on the following document, clean the text and translate it to both English and Arabic\ntext = {'Arabic': string, 'English': string}\nReturn: Array<text>",
  statusTypes: {
    processing: "processing",
    success: "success",
    failed: "failed"
  }
};
```

- `performOcrPrompt`: The prompt used in the main OCR functionality
- `statusTypes`: Standard status types used across the application

## How to Customize

To modify any of these settings, simply edit the `convex/config.ts` file and update the values as needed. The changes will be applied the next time the corresponding code runs.

For example, to update the OpenAI model:

```typescript
// In convex/config.ts
export const openai = {
  model: "gpt-4-turbo", // Changed from gpt-4o to gpt-4-turbo
  temperature: 0.3,
  // ...other settings...
};
```

## Adding New Configuration

If you need to add new configuration values:

1. Add them to the appropriate section in `convex/config.ts`
2. Import the configuration in the file where you need to use it
3. Use the imported configuration values instead of hardcoded ones

Example:

```typescript
// In your file
import { openai as openaiConfig } from "../../config";

// Use the configuration
const response = await openai.chat.completions.create({
  model: openaiConfig.model,
  // ...other settings...
});
``` 


// File Path: convex/convex.config.ts

import { defineApp } from "convex/server";
import workflow from "@convex-dev/workflow/convex.config";

const app = defineApp();
app.use(workflow);

export default app;


// File Path: convex/files/mutations.ts

// convex/files/mutations.ts
import { mutation } from "../_generated/server";

// Public mutation: Called by the client to get a URL to upload a file *to*.
export const generateUploadUrl = mutation({
  handler: async (ctx) => {
    try {
      const uploadUrl = await ctx.storage.generateUploadUrl();
      console.log("Generated upload URL.");
      return uploadUrl;
    } catch {
      throw new Error("Could not create upload URL, please try again later.");
    }
  

  },
});


// File Path: convex/files/queries.ts

// convex/files/queries.ts
import { query } from "../_generated/server";
import { v } from "convex/values";

// Query to get a short-lived downloadable URL for a file stored in Convex storage.
export const getFileDownloadUrl = query({
  args: {
    fileId: v.id("_storage"), // Changed to use v.id for proper storage ID validation
  },
  handler: async (ctx, args) => {
    try {
      const url = await ctx.storage.getUrl(args.fileId);
      if (!url) {
        console.warn(
          `Could not generate download URL for fileId: ${args.fileId}. File might not exist.`
        );
        throw new Error("Unable to generate download URL right now.");
      }
      return url;
    } catch (error) {
      console.error(
        `Error generating download URL for fileId ${args.fileId}:`,
        error
      );
      throw new Error("Failed to generate download URL.");
    }
  },
});



// File Path: convex/http.ts

import { httpRouter } from "convex/server";
import { cleanHandler, cleanPageHandler } from "./api";

const http = httpRouter();


http.route({
  path: "/clean",
  method: "POST",
  handler: cleanHandler
});
http.route({
  path: "/clean",
  method: "OPTIONS",
  handler: cleanHandler   // httpAction will catch OPTIONS itself
});

http.route({
  path: "/cleanPage",
  method: "POST",
  handler: cleanPageHandler
});
http.route({
  path: "/cleanPage",
  method: "OPTIONS",
  handler: cleanPageHandler   // httpAction will catch OPTIONS itself
});

export default http;


// File Path: convex/ingest/ingest.ts

import { v } from "convex/values";
import {
  action,
  internalAction,
  internalMutation,
  internalQuery,
} from "../_generated/server";
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";
import { asyncMap } from "modern-async";
import { api, internal } from "../_generated/api";
import { openai } from "@ai-sdk/openai";
import { embedMany } from "ai";
import { embedding as embeddingConfig } from "../config";
import { Id } from "../_generated/dataModel";

export const createChunks = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, arg) => {
    const pdf = await ctx.db.get(arg.pdfId);
    if (!pdf) {
      throw new Error("PDF not found");
    }
    console.log("Creating chunks for PDF:", pdf._id);

    const existingChunks = await ctx.db
      .query("chunks")
      .withIndex("byPdfId", (q) => q.eq("pdfId", arg.pdfId))
      .first();

    if (existingChunks) {
      console.log(
        `Chunks already exist for PDF ${arg.pdfId}, skipping creation`
      );
      return;
    }

    const cleanedPages = await ctx.db
      .query("openaiCleanedPage")
      .filter((q) => q.eq(q.field("cleaningStatus"), "completed"))
      .collect();

    const pdfPages = new Map<Id<"pages">, string>();

    for (const cleanedPage of cleanedPages) {
      const page = await ctx.db.get(cleanedPage.pageId);
      if (page && page.pdfId === arg.pdfId) {
        pdfPages.set(cleanedPage.pageId, cleanedPage.cleanedText);
      }
    }

    console.log(`Found ${pdfPages.size} cleaned pages for PDF ${arg.pdfId}`);

    if (pdfPages.size === 0) {
      console.log("No cleaned pages found, trying whole-PDF approach...");

      // Fallback to whole-PDF chunks for backward compatibility
      const pdfTextId = await ctx.db
        .query("openaiOcrResults")
        .withIndex("by_pdf_id", (q) => q.eq("pdfId", arg.pdfId))
        .filter((q) => q.eq(q.field("cleaningStatus"), "completed"))
        .first();

      if (!pdfTextId?.cleanedText) {
        console.log("No cleaned text available for chunking");
        return;
      }

      // Create document-level chunks with pageId: null
      const splitter = RecursiveCharacterTextSplitter.fromLanguage("markdown", {
        chunkSize: embeddingConfig.chunking.chunkSize,
        chunkOverlap: embeddingConfig.chunking.chunkOverlap,
      });

      const chunks = await splitter.splitText(pdfTextId.cleanedText);
      await asyncMap(chunks, async (chunk) => {
        await ctx.db.insert("chunks", {
          pdfId: arg.pdfId,
          pageId: null, // Document-level chunk
          text: chunk,
          embeddingId: null,
        });
      });

      console.log(
        `Created ${chunks.length} document-level chunks for PDF ${arg.pdfId}`
      );
      return;
    }

    // Create page-level chunks
    const splitter = RecursiveCharacterTextSplitter.fromLanguage("markdown", {
      chunkSize: embeddingConfig.chunking.chunkSize,
      chunkOverlap: embeddingConfig.chunking.chunkOverlap,
    });

    let totalChunks = 0;

    // Process each page
    for (const [pageId, cleanedText] of pdfPages.entries()) {
      const chunks = await splitter.splitText(cleanedText);

      await asyncMap(chunks, async (chunk) => {
        await ctx.db.insert("chunks", {
          pdfId: arg.pdfId,
          pageId: pageId, // Page-specific chunk
          text: chunk,
          embeddingId: null,
        });
      });

      console.log(`Created ${chunks.length} chunks for page ${pageId}`);
      totalChunks += chunks.length;
    }

    console.log(
      `Created ${totalChunks} page-level chunks for PDF ${arg.pdfId}`
    );

    // Also create document-level chunks as a fallback
    // This maintains backward compatibility and helps with broad queries
    console.log("Creating additional document-level chunks...");

    const allPageTexts = Array.from(pdfPages.values()).join("\n\n");
    const docChunks = await splitter.splitText(allPageTexts);

    await asyncMap(docChunks, async (chunk) => {
      await ctx.db.insert("chunks", {
        pdfId: arg.pdfId,
        pageId: null, // Document-level chunk
        text: chunk,
        embeddingId: null,
      });
    });

    console.log(
      `Created ${docChunks.length} document-level chunks for backward compatibility`
    );
    console.log(`Total chunks created: ${totalChunks + docChunks.length}`);
  },
});

export const getChunkStats = internalQuery({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args) => {
    const allChunks = await ctx.db
      .query("chunks")
      .withIndex("byPdfId", (q) => q.eq("pdfId", args.pdfId))
      .collect();

    const pageChunks = allChunks.filter((chunk) => chunk.pageId !== null);
    const docChunks = allChunks.filter((chunk) => chunk.pageId === null);
    const chunksWithEmbeddings = allChunks.filter(
      (chunk) => chunk.embeddingId !== null
    );

    return {
      total: allChunks.length,
      pageLevel: pageChunks.length,
      documentLevel: docChunks.length,
      withEmbeddings: chunksWithEmbeddings.length,
      pagesRepresented: new Set(pageChunks.map((c) => c.pageId)).size,
    };
  },
});

export async function embedTexts(texts: string[]) {
  if (texts.length === 0) return [];

  console.log(`Embedding ${texts.length} texts...`);

  try {
    const { embeddings } = await embedMany({
      model: openai.embedding(embeddingConfig.model),
      values: texts,
    });

    console.log(`Successfully created ${embeddings.length} embeddings`);
    return embeddings;
  } catch (error) {
    console.error("Error creating embeddings:", error);
    throw error;
  }
}

export const chunksNeedingEmbedding = internalQuery({
  args: { pdfId: v.id("pdfs") },
  handler: async (ctx, args) => {
    const chunks = await ctx.db
      .query("chunks")
      .withIndex("byPdfId", (q) => q.eq("pdfId", args.pdfId))
      .filter((q) => q.eq(q.field("embeddingId"), null))
      .collect();
    return chunks;
  },
});

export const embedList = internalAction({
  args: {
    documentIds: v.array(v.id("pdfs")),
  },
  handler: async (ctx, { documentIds }) => {
    // Get all chunks needing embedding, with their associated PDF IDs
    type ChunkWithPdfId = {
      _id: Id<"chunks">;
      pdfId: Id<"pdfs">;
      pageId: Id<"pages"> | null;
      text: string;
      embeddingId: Id<"embeddings"> | null;
    };

    const chunksWithPdfIds: ChunkWithPdfId[] = [];

    for (const pdfId of documentIds) {
      // Defensive programming: skip if no documentIds
      if (!documentIds.length) continue;

      const chunks = await ctx.runQuery(
        internal.ingest.ingest.chunksNeedingEmbedding,
        { pdfId }
      );

      // FIX: Remove the extra dot - spread the inner map correctly
      if (chunks && chunks.length > 0) {
        chunksWithPdfIds.push(
          ...chunks.map((chunk: ChunkWithPdfId) => ({ ...chunk, pdfId })) // ‚úÖ Added type annotation
        );
      }
    }

    console.log(
      `Embedding ${chunksWithPdfIds.length} chunks across ${documentIds.length} PDFs`
    );

    // Only process if we have chunks
    if (chunksWithPdfIds.length === 0) {
      console.log("No chunks to embed");
      return;
    }

    try {
      // Get embeddings for all chunk texts
      const embeddings = await embedTexts(
        chunksWithPdfIds.map((chunk) => chunk.text)
      );

      // Save embeddings with their correct chunk and PDF IDs
      await asyncMap(embeddings, async (embedding, i) => {
        const chunk = chunksWithPdfIds[i];
        await ctx.runMutation(internal.ingest.ingest.addEmbedding, {
          chunkId: chunk._id,
          embedding,
          pdfId: chunk.pdfId,
          pageId: chunk.pageId, // ‚úÖ Include pageId for page-level tracking
        });
      });

      console.log(`Successfully embedded ${embeddings.length} chunks`);
    } catch (error) {
      console.error("Error in embedList:", error);
      throw error;
    }
  },
});

export const addEmbedding = internalMutation({
  args: {
    chunkId: v.id("chunks"),
    embedding: v.array(v.number()),
    pdfId: v.id("pdfs"),
    pageId: v.optional(v.union(v.id("pages"), v.null())), // New optional pageId
  },
  handler: async (ctx, args) => {
    // Get the chunk to check if it already has an embedding
    const chunk = await ctx.db.get(args.chunkId);
    if (!chunk) {
      console.error("Chunk not found:", args.chunkId);
      return;
    }

    // Skip if the chunk already has an embedding
    if (chunk.embeddingId !== null) {
      console.log("Chunk already has embedding, skipping:", args.chunkId);
      return;
    }

    // Create the embedding with pageId support
    const embeddingId = await ctx.db.insert("embeddings", {
      embedding: args.embedding,
      chunkId: args.chunkId,
      pdfId: args.pdfId,
      pageId: args.pageId || null, // Store the pageId from chunk
    });

    await ctx.db.patch(args.chunkId, { embeddingId });

    console.log(
      `Created embedding for chunk ${args.chunkId} (${args.pageId ? `page ${args.pageId}` : "document level"})`
    );
  },
});

export const chunkAndEmbed = action({
  args: { pdfId: v.id("pdfs") },
  handler: async (
    ctx,
    args
  ): Promise<
    | {
        success: boolean;
        pdfId: Id<"pdfs">;
        source: "gemini" | "replicate";
        timestamp: number;
      }
    | undefined
  > => {
    // ‚úÖ Added explicit return type
    console.log(`Starting chunkAndEmbed orchestration for PDF: ${args.pdfId}`);

    try {
      // ‚ë† Wait until *all* pages are cleaned
      // We'll check both Gemini and Replicate sources
      const geminiReady: boolean = await ctx.runQuery(
        internal.concatenate.queries.areAllPagesComplete,
        { pdfId: args.pdfId, source: "gemini" }
      );

      const replicateReady: boolean = await ctx.runQuery(
        internal.concatenate.queries.areAllPagesComplete,
        { pdfId: args.pdfId, source: "replicate" }
      );

      // For now, we proceed if either source is complete
      // (This can be configured to wait for both if needed)
      if (!geminiReady && !replicateReady) {
        console.log(
          `Pages not yet ready for PDF ${args.pdfId}. Gemini: ${geminiReady}, Replicate: ${replicateReady}`
        );
        return;
      }

      const readySource: "gemini" | "replicate" = geminiReady
        ? "gemini"
        : "replicate";
      console.log(`All pages ready for PDF ${args.pdfId} using ${readySource}`);

      // ‚ë° Create/update chunks
      console.log(`Creating chunks for PDF ${args.pdfId}...`);
      await ctx.runMutation(internal.ingest.ingest.createChunks, {
        pdfId: args.pdfId,
      });

      // ‚ë¢ Schedule embedding
      console.log(`Scheduling embedding for PDF ${args.pdfId}...`);
      await ctx.scheduler.runAfter(0, internal.ingest.ingest.embedList, {
        documentIds: [args.pdfId],
      });

      console.log(
        `Successfully orchestrated chunking and embedding for PDF ${args.pdfId}`
      );

      // Optional: Return status for monitoring
      return {
        success: true,
        pdfId: args.pdfId,
        source: readySource,
        timestamp: Date.now(),
      };
    } catch (error) {
      console.error(
        `Error in chunkAndEmbed orchestration for PDF ${args.pdfId}:`,
        error
      );
      throw error;
    }
  },
});

export const getEmbedding = internalQuery({
  args: { pdfId: v.id("pdfs") },
  handler: async (ctx, args) => {
    const embedding = await ctx.db
      .query("embeddings")
      .withIndex("byPdfId", (q) => q.eq("pdfId", args.pdfId))
      .first();
    return embedding;
  },
});

export const triggerChunkAndEmbedFromPageCleaning = action({
  args: {
    pageId: v.id("pages"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, args): Promise<void> => {
    // ‚úÖ Added explicit return type
    console.log(
      `Page cleaning completed for page ${args.pageId}, checking if PDF is ready...`
    );

    // Get the PDF ID from the page
    const page = await ctx.runQuery(api.pdf.queries.getPdfPage, {
      pageId: args.pageId,
    });

    if (!page) {
      console.error(`Page not found: ${args.pageId}`);
      return;
    }

    // Check if all pages for this PDF are now ready
    const allReady = await ctx.runQuery(
      internal.concatenate.queries.areAllPagesComplete,
      { pdfId: page.pdfId, source: args.source }
    );

    if (allReady) {
      console.log(
        `All pages ready for PDF ${page.pdfId}, triggering chunkAndEmbed...`
      );

      // Trigger the orchestration
      await ctx.runAction(api.ingest.ingest.chunkAndEmbed, {
        pdfId: page.pdfId,
      });
    } else {
      console.log(`Not all pages ready yet for PDF ${page.pdfId}, waiting...`);
    }
  },
});

// Utility to check orchestration status
export const getOrchestrationStatus = action({
  args: { pdfId: v.id("pdfs") },
  handler: async (
    ctx,
    args
  ): Promise<{
    pdfId: Id<"pdfs">;
    readiness: {
      gemini: boolean;
      replicate: boolean;
    };
    chunking: {
      hasChunks: boolean;
      pageLevel: number;
      documentLevel: number;
      withEmbeddings: number;
    };
    status:
      | "completed"
      | "embedding_pending"
      | "chunking_pending"
      | "pages_pending";
  }> => {
    // ‚úÖ Added explicit return type
    // Check readiness status
    const geminiReady = await ctx.runQuery(
      internal.concatenate.queries.areAllPagesComplete,
      { pdfId: args.pdfId, source: "gemini" }
    );

    const replicateReady = await ctx.runQuery(
      internal.concatenate.queries.areAllPagesComplete,
      { pdfId: args.pdfId, source: "replicate" }
    );

    // Check if chunks exist
    const chunkStats = await ctx.runQuery(
      internal.ingest.ingest.getChunkStats,
      { pdfId: args.pdfId }
    );

    return {
      pdfId: args.pdfId,
      readiness: {
        gemini: geminiReady,
        replicate: replicateReady,
      },
      chunking: {
        hasChunks: chunkStats.total > 0,
        pageLevel: chunkStats.pageLevel,
        documentLevel: chunkStats.documentLevel,
        withEmbeddings: chunkStats.withEmbeddings,
      },
      // Determine overall status
      status:
        chunkStats.withEmbeddings > 0
          ? "completed"
          : chunkStats.total > 0
            ? "embedding_pending"
            : geminiReady || replicateReady
              ? "chunking_pending"
              : "pages_pending",
    };
  },
});



// File Path: convex/ocr/gemini/actions.ts

// convex/ocr/gemini/actions.ts
import { action, internalAction } from "../../_generated/server";
import { v } from "convex/values";
import { api, internal } from "../../_generated/api";
import { Id } from "../../_generated/dataModel";
import { createPartFromUri, GoogleGenAI, Part } from "@google/genai";
import { gemini as geminiConfig } from "../../config";
import main from "../../utils/geminiOcr";
import geminiPageOcr from "../../utils/geminiOcr";

// Define valid status types to match the schema




// Action to process a PDF using Google Gemini AI for OCR
export const processPdfWithOcr = action({
  args: {
    pdfId: v.id("pdfs"), 
  },
  handler: async (ctx, args)=> {
    try {

      const current = await ctx.runQuery(api.pdf.queries.getPdf, { pdfId: args.pdfId });
      if (!current ) {
        throw new Error("PDF must be uploaded before OCR.");
      }
      

      // 1. Update PDF status to "processing" for Gemini
      await ctx.runMutation(internal.ocr.gemini.mutations.updateOcrStatus, {
        pdfId: args.pdfId as Id<"pdfs">,
        ocrStatus: "processing",
      });
      console.log(`Gemini processing started for PDF: ${args.pdfId}`);

     

      // 3. Fetch the actual PDF file content from Convex storage
      const fileData = await ctx.storage.getUrl(current.fileId);
      if (!fileData) {
        throw new Error(`PDF file blob not found in storage for fileId: ${current.fileId}`);
      }
      console.log(fileData);

      const pdfBuffer = await fetch(fileData)
        .then((response) => response.arrayBuffer());
      // 4. Prepare the file data for the Gemini API
      const fileBlob: Blob = new Blob([pdfBuffer], { type: 'application/pdf' });

      const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
      if (!GEMINI_API_KEY) {
        throw new Error("Gemini API key (GEMINI_API_KEY) is not configured in Convex environment variables.");
      }

      const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
      const modelName = geminiConfig.model;

      const file = await ai.files.upload({
        file: fileBlob,
        config: {
          displayName: '.pdf',
        },
      });

      if (!file.name) {
        throw new Error("File name is not available.");
      }

      // Wait for the file to be processed.
      let getFile = await ai.files.get({ name: file.name });
      while (getFile.state === 'PROCESSING') {
        getFile = await ai.files.get({ name: file.name });
        console.log(`current file status: ${getFile.state}`);
        console.log('File is still processing, retrying in 5 seconds');

        await new Promise((resolve) => {
          setTimeout(resolve, geminiConfig.fileProcessingPollingIntervalMs);
        });
      }
      if (file.state === 'FAILED') {
        throw new Error('File processing failed.');
      }

      // 6. Create the prompt and file part
      const prompt: (string | Part)[] = [geminiConfig.prompt];

      if (file.uri && file.mimeType) {
        const fileContent = createPartFromUri(file.uri, file.mimeType);
        prompt.push(fileContent);
      }

      const response = await ai.models.generateContent({
        model: modelName,
        contents: prompt,
      });
      // 8. Extract the text from the response

      if (!response.text) {
        throw new Error("Gemini API did not return any text content.");
      }

      console.log(response.text);

      console.log(`Gemini OCR successful for PDF ${args.pdfId}. Text length: ${response.candidates?.[0]?.tokenCount}`);

      // 9. Save the extracted text and update PDF status
      await ctx.runMutation(internal.ocr.gemini.mutations.updateOcrResutls, {
        pdfId: args.pdfId,
        extractedText: response.text,
        ocrStatus: "completed",
      });

    
      // 10. Immediately trigger OpenAI cleanup without waiting for other OCR services
      console.log(`Immediately triggering OpenAI cleanup for Gemini OCR results of PDF ${args.pdfId}`);

      // 11. Return success status
      

    } catch (error: unknown) {
      console.error(`Gemini OCR failed for PDF ${args.pdfId}:`, error);

      await ctx.runMutation(internal.ocr.gemini.mutations.updateOcrStatus, {
        pdfId: args.pdfId,
        ocrStatus: "failed",
      });

    }
  },
});







// Action to process a single page with Google Gemini AI for OCR
export const processPageWithOcr = internalAction({
  args: {
    pageId: v.id("pages"),
  },
  handler: async (ctx, args): Promise<{ success: boolean; pageId: Id<"pages">; provider: string }> => {
    try {
      // Get the page details
      const page = await ctx.runQuery(api.pdf.queries.getPdfPage, { pageId: args.pageId });
      if (!page) {
        throw new Error(`Page not found for ID: ${args.pageId}`);
      }

      // Update the page OCR status to "processing"
      await ctx.runMutation(internal.ocr.gemini.mutations.updatePageOcrStatus, {
        pageId: args.pageId,
        ocrStatus: "processing",
      });
      
      console.log(`Gemini processing started for page: ${args.pageId} (page ${page.pageNumber})`);

      const fileId = page.fileId;

      // Fetch the page file content from Convex storage
      const fileUrl = await ctx.storage.getUrl(fileId);
      
      if (!fileUrl) {
        throw new Error(`Page file not found in storage for fileId: ${page.fileId}`);
      }

     

      

      // Generate content with retry
      const response = await geminiPageOcr(fileUrl);
      console.log("Response from Gemini: ", response);

      if (!response.text) {
        throw new Error("Gemini API did not return any text content.");
      }

      console.log(`Gemini OCR successful for page ${args.pageId}. Text length: ${response.text.length}`);

      // Save the extracted text and update page OCR status
      await ctx.runMutation(internal.ocr.gemini.mutations.updatePageOcrResults, {
        pageId: args.pageId,
        extractedText: response.text,
        ocrStatus: "completed",
      });

      // Later in Sprint 5, we'll immediately trigger OpenAI cleanup here
      
      return { 
        success: true, 
        pageId: args.pageId,
        provider: "gemini",
      };
    } catch (error) {
      console.error(`Gemini OCR failed for page ${args.pageId}:`, error);

      // Update status to failed
      await ctx.runMutation(internal.ocr.gemini.mutations.updatePageOcrStatus, {
        pageId: args.pageId,
        ocrStatus: "failed",
      });

      throw error;
    }
  },
});


// File Path: convex/ocr/gemini/mutations.ts

// convex/ocr/gemini/mutations.ts
import { internalMutation } from "../../_generated/server";
import { v } from "convex/values";


export const updateOcrStatus = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    ocrStatus: v.union(v.literal("processing"), v.literal("failed")),
  },
  handler: async (ctx, args) => {
    const [row] = await ctx.db
      .query("geminiOcrResults")
      .withIndex("by_pdf_id", q => q.eq("pdfId", args.pdfId))
      .collect();
    if (row) {
      // update it
      await ctx.db.patch(row._id, {
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    } else {
      // or insert a new one
      await ctx.db.insert("geminiOcrResults", {
        pdfId: args.pdfId,
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    }
  },
});


export const updateOcrResutls = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    extractedText: v.string(),
    ocrStatus: v.string(),
  },
  handler: async (ctx, args): Promise<void> => {

    const [row] = await ctx.db
      .query("geminiOcrResults")
      .withIndex("by_pdf_id", q => q.eq("pdfId", args.pdfId))
      .collect();

    if (row) {
    await ctx.db.patch(row._id, {
      extractedText: args.extractedText,
      ocrStatus: "completed",
    });
    } else {
      throw new Error("Gemini OCR results not found for PDF ID: " + args.pdfId);
    }
  },
});

// convex/ocr/gemini/mutations.ts - Add to existing file

export const updatePageOcrStatus = internalMutation({
  args: {
    pageId: v.id("pages"),
    ocrStatus: v.union(v.literal("processing"), v.literal("failed")),
  },
  handler: async (ctx, args): Promise<void> => {
    const row = await ctx.db
      .query("geminiPageOcr")
      .withIndex("by_page_id", q => q.eq("pageId", args.pageId))
      .first();
      
    if (row) {
      // update existing row
      await ctx.db.patch(row._id, {
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    } else {
      // insert a new row
      await ctx.db.insert("geminiPageOcr", {
        pageId: args.pageId,
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    }
  },
});

export const updatePageOcrResults = internalMutation({
  args: {
    pageId: v.id("pages"),
    extractedText: v.string(),
    ocrStatus: v.string(),
  },
  handler: async (ctx, args): Promise<void> => {
    const row = await ctx.db
      .query("geminiPageOcr")
      .withIndex("by_page_id", q => q.eq("pageId", args.pageId))
      .first();

    if (row) {
      await ctx.db.patch(row._id, {
        extractedText: args.extractedText,
        ocrStatus: "completed",
        processedAt: Date.now(),
      });
    } else {
      // In case the row doesn't exist yet
      await ctx.db.insert("geminiPageOcr", {
        pageId: args.pageId,
        extractedText: args.extractedText,
        ocrStatus: "completed",
        processedAt: Date.now(),
      });
    }
  },
});








  


// File Path: convex/ocr/gemini/queries.ts

// convex/ocr/gemini/queries.ts
import { query } from "../../_generated/server";
import { v } from "convex/values";

// Get Gemini OCR results specifically for a given PDF ID
export const getOcrResults = query({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args) => {
    const pdf = await ctx.db.get(args.pdfId);
    if (!pdf) {
      
      console.warn(`PDF not found in gemini/getOcrResults query for ID: ${args.pdfId}`);
      return null; 
    }


    const ocrResults = await ctx.db
      .query("geminiOcrResults")
      .withIndex("by_pdf_id", (q) => q.eq("pdfId", args.pdfId))
      .first(); 

    return {
      pdf, 
      ocrResults, 
    };
  },
});


export const getOcrStatus = query({
  args: {
    pdfId: v.id("geminiOcrResults"),
  },
  handler: async (ctx, args) => {
    const ocrResults = await ctx.db.get(args.pdfId);
    if (!ocrResults) {
     throw new Error("PDF not found in Gemini OCR for ID: ${args.pdfId}");
    }
    return {ocrStatus: ocrResults.ocrStatus};
  },

});

export const getOcrByPdfId = query({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args) => {
    return  await ctx.db
    .query("geminiOcrResults")
    .withIndex("by_pdf_id", q => q.eq("pdfId", args.pdfId))
    .collect();
  }
})


export const getPageOcrResults = query({
  args: {
    pageId: v.id("pages"),
  },
  handler: async (ctx, args) => {
    const page = await ctx.db.get(args.pageId);
    if (!page) {
      console.warn(`Page not found in gemini/getPageOcrResults query for ID: ${args.pageId}`);
      return null;
    }

    const ocrResults = await ctx.db
      .query("geminiPageOcr")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .first();

    return {
      page,
      ocrResults,
    };
  },
});

export const getPageOcrStatus = query({
  args: {
    pageId: v.id("pages"),
  },
  handler: async (ctx, args) => {
    const ocrResults = await ctx.db
      .query("geminiPageOcr")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .first();
      
    if (!ocrResults) {
      return { ocrStatus: null };
    }
    
    return { ocrStatus: ocrResults.ocrStatus };
  },
});


// File Path: convex/ocr/openai/actions.ts

// convex/ocr/openai/actions.ts - Create new file or add to existing

import { internalAction } from "../../_generated/server";
import { v } from "convex/values";
import { internal } from "../../_generated/api";

export const cleanPage = internalAction({
  args: {
    pageId: v.id("pages"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, args) => {
    const { pageId, source } = args;
    
    try {
      // Mark as started
      await ctx.runMutation(internal.ocr.openai.mutations.updatePageCleaningStatus, { 
        pageId, 
        source, 
        cleaningStatus: "started" 
      });
      
      // Get the base URL for our HTTP endpoint
      const HTTP_BASE = process.env.CONVEX_SITE_URL;
      if (!HTTP_BASE) {
        throw new Error("Missing CONVEX_SITE_URL environment variable");
      }
      
      // Call the /cleanPage HTTP endpoint
      const res = await fetch(`${HTTP_BASE}/cleanPage`, {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ pageId, source }),
      });
      
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`cleanPage HTTP failed: ${res.status} - ${errorText}`);
      }
      
      // Drain the stream to ensure completion
      await res.text();
      
      console.log(`Successfully cleaned page ${pageId} with ${source} OCR via HTTP`);
      
      return {
        success: true,
        pageId,
        source
      };
    } catch (error) {
      console.error(`Error cleaning page ${pageId} with ${source} OCR:`, error);
      throw error;
    }
  },
});


// File Path: convex/ocr/openai/mutations.ts

import { internalMutation } from "../../_generated/server";
import { v } from "convex/values";

export const saveCleanedResults = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    cleanedText: v.string(),
    cleaningStatus: v.literal("completed"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, args) => {

    
        // Insert new record
        // patch the results with index pdfId and source
        const existingJob = await ctx.db.query("openaiOcrResults")
        .withIndex("by_pdf_id", (q) => q.eq("pdfId", args.pdfId))
        .filter((q) => q.eq(q.field("source"), args.source)).first();

        if (existingJob) {
          console.log("Patching existing record");
          await ctx.db.patch(existingJob._id, {
            pdfId: args.pdfId,
            cleanedText: args.cleanedText,
            cleaningStatus: args.cleaningStatus,
            processedAt: Date.now(),
          });
          
        }
        else {
          console.log("Inserting new record");
          await ctx.db.insert("openaiOcrResults", {
            pdfId: args.pdfId,
            cleanedText: args.cleanedText,
            cleaningStatus: args.cleaningStatus,
            processedAt: Date.now(),
            source: args.source,
          });
        }
        
        

  },
}); 


export const updateCleanedStatus = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    cleaningStatus: v.literal("started"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
    cleanedText: v.string(),
  },
  handler: async (ctx, args) => {
    // Check if we already have results for this PDF
    const pdfJob = await ctx.db.get(args.pdfId);
    if (!pdfJob) {
        throw new Error("PDF is not ready for cleaning");
    }

    const existingJob = await ctx.db.query("openaiOcrResults")
    .withIndex("by_pdf_id", (q) => q.eq("pdfId", args.pdfId))
    .filter((q) => q.eq(q.field("source"), args.source)).first();

    if (existingJob) {
      await ctx.db.patch(existingJob._id, {
        pdfId: args.pdfId,
        cleaningStatus: args.cleaningStatus,
        source: args.source,
        processedAt: Date.now(),
      });
    }


    else {
      await ctx.db.insert("openaiOcrResults", {
        pdfId: args.pdfId,
        cleaningStatus: args.cleaningStatus,
        source: args.source,
        processedAt: Date.now(),
        cleanedText: "",
      });
    }
    }

        
  }); 





  // convex/ocr/openai/mutations.ts - Add to existing file

export const updatePageCleaningStatus = internalMutation({
  args: {
    pageId: v.id("pages"),
    cleaningStatus: v.union(v.literal("started"), v.literal("completed")),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
    cleanedText: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Check if we already have results for this page
    const page = await ctx.db.get(args.pageId);
    if (!page) {
      throw new Error("Page not found");
    }

    const existingCleaned = await ctx.db.query("openaiCleanedPage")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .filter((q) => q.eq(q.field("source"), args.source))
      .first();

    if (existingCleaned) {
      const update: any = {
        cleaningStatus: args.cleaningStatus,
        processedAt: Date.now(),
      };
      
      if (args.cleanedText !== undefined) {
        update.cleanedText = args.cleanedText;
      }
      
      await ctx.db.patch(existingCleaned._id, update);
    } else {
      const insert: any = {
        pageId: args.pageId,
        cleaningStatus: args.cleaningStatus,
        source: args.source,
        processedAt: Date.now(),
        cleanedText: args.cleanedText || "",
      };
      
      await ctx.db.insert("openaiCleanedPage", insert);
    }
  },
});

export const savePageCleanedResults = internalMutation({
  args: {
    pageId: v.id("pages"),
    cleanedText: v.string(),
    cleaningStatus: v.literal("completed"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, args) => {
    const existingJob = await ctx.db.query("openaiCleanedPage")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .filter((q) => q.eq(q.field("source"), args.source))
      .first();

    if (existingJob) {
      await ctx.db.patch(existingJob._id, {
        cleanedText: args.cleanedText,
        cleaningStatus: args.cleaningStatus,
        processedAt: Date.now(),
      });
    } else {
      await ctx.db.insert("openaiCleanedPage", {
        pageId: args.pageId,
        cleanedText: args.cleanedText,
        cleaningStatus: args.cleaningStatus,
        processedAt: Date.now(),
        source: args.source,
      });
    }
  },
});

// convex/ocr/openai/mutations.ts (update the startPageCleaning function)
export const startPageCleaning = internalMutation({
  args: { 
    pageId: v.id("pages"), 
    source: v.union(v.literal("gemini"), v.literal("replicate"))
  },
  handler: async (ctx, { pageId, source }) => {
    const existing = await ctx.db
      .query("openaiCleanedPage")
      .withIndex("by_page_source", q => 
        q.eq("pageId", pageId).eq("source", source))
      .unique();
    
    // Change this condition to handle the schema type
    if (existing && existing.cleaningStatus === "completed") {
      return "completed";
    }
    
    if (existing) {
      await ctx.db.patch(existing._id, { cleaningStatus: "started" }); // Use "started" instead of "processing"
    } else {
      await ctx.db.insert("openaiCleanedPage", {
        pageId,
        source,
        cleaningStatus: "started", // Use "started" instead of "processing"
        cleanedText: "",
        processedAt: Date.now(),
      });
    }
    
    return "started";
  },
});


// File Path: convex/ocr/openai/queries.ts

import { query } from "../../_generated/server";
import { v } from "convex/values";

// Get OpenAI cleaned OCR results for a given PDF
export const getCleanedResults = query({
  args: {
    pdfId: v.id("pdfs"),
    source: v.optional(v.union(v.literal("gemini"), v.literal("replicate"))),
  },
  handler: async (ctx, args) => {
    // Get the PDF document
    const pdf = await ctx.db.get(args.pdfId);
    if (!pdf) {
      console.warn(`PDF not found in openai/getCleanedResults query for ID: ${args.pdfId}`);
      return null;
    }

    // Build the query
    const [ocrResults]  = await ctx.db
      .query("openaiOcrResults")
      .withIndex("by_pdf_id", (q) => q.eq("pdfId", args.pdfId))
      .collect();

    const cleanedResults = ocrResults.cleanedText;



    // Return structured result
    return {
      cleanedResults,
    };
  },
}); 

export const getCleanedId = query({
  args: {
    pdfId: v.id("pdfs"),
    source: v.optional(v.union(v.literal("gemini"), v.literal("replicate"))),
  },
  handler: async (ctx, args) => {
    // Get the PDF document
    const pdf = await ctx.db.get(args.pdfId);
    if (!pdf) {
      console.warn(`PDF not found in openai/getCleanedResults query for ID: ${args.pdfId}`);
      return null;
    }

  
    return await ctx.db
    .query("openaiOcrResults")
    .withIndex("by_pdf_id", (q) => q.eq("pdfId", args.pdfId))
    .filter((q) => q.eq(q.field("source"), args.source))
    .collect();
  },
}); 







// convex/ocr/openai/queries.ts - Add to existing file

export const getPageCleanedResults = query({
  args: {
    pageId: v.id("pages"),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, args) => {
    // Get the page
    const page = await ctx.db.get(args.pageId);
    if (!page) {
      console.warn(`Page not found in openai/getPageCleanedResults query for ID: ${args.pageId}`);
      return null;
    }

    // Query for cleaned results
    const cleanedResult = await ctx.db
      .query("openaiCleanedPage")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .filter((q) => q.eq(q.field("source"), args.source))
      .first();

    if (!cleanedResult) {
      return { page, cleanedText: null, cleaningStatus: null };
    }

    return {
      page,
      cleanedText: cleanedResult.cleanedText,
      cleaningStatus: cleanedResult.cleaningStatus,
    };
  },
});


// File Path: convex/ocr/replicate/actions.ts

// convex/ocr/replicate/actions.ts
import { action, internalAction } from "../../_generated/server";
import { v } from "convex/values";
import { api, internal } from "../../_generated/api";
import Replicate from "replicate";
import { Id } from "../../_generated/dataModel";
import { replicate as replicateConfig } from "../../config";
import { runWithRetry } from "../../utils/retry";

/* ------------------------------------------------------------------ *
 * 1. Helper: merge *all* chunks returned by lucataco/olmocr-7b
 * ------------------------------------------------------------------ */
function extractOCRText(replicateOutput: unknown): string {
  /* normalise to an array of stringified chunks */
  const chunks: string[] = (() => {
    if (Array.isArray(replicateOutput)) return replicateOutput.map(String);
    if (typeof replicateOutput === "string") return [replicateOutput];
    if (
      replicateOutput &&
      typeof replicateOutput === "object" &&
      "output" in replicateOutput
    ) {
      const out = (replicateOutput as any).output;
      return Array.isArray(out) ? out.map(String) : [String(out)];
    }
    return [JSON.stringify(replicateOutput)];
  })();

  /* pull natural_text (or best effort) out of every chunk */
  const texts = chunks.map((chunk) => {
    try {
      const obj = JSON.parse(chunk);
      if (obj && typeof obj.natural_text === "string") return obj.natural_text;
    } catch {
      /* not JSON ‚Äì fall through */
    }
    const m = chunk.match(/natural_text["']\s*:\s*["']([^"']+)["']/);
    return m ? m[1].replace(/\\n/g, "\n").replace(/\\"/g, '"') : chunk;
  });

  return texts.join("\n");
}

const replicate = new Replicate({ auth: process.env.REPLICATE_API_TOKEN });

/* ------------------------------------------------------------------ *
 * 2. Whole-PDF OCR (unchanged except for chunk fix + token limit bump)
 * ------------------------------------------------------------------ */
export const processPdfWithOcr = action({
  args: { pdfId: v.id("pdfs") },
  handler: async (ctx, args) => {
    try {
      const current = await ctx.runQuery(api.pdf.queries.getPdf, {
        pdfId: args.pdfId,
      });
      if (!current) throw new Error("PDF must be uploaded before OCR.");

      await ctx.runMutation(internal.ocr.replicate.mutations.updateOcrStatus, {
        pdfId: args.pdfId as Id<"pdfs">,
        ocrStatus: "processing",
      });

      const fileData = await ctx.storage.getUrl(current.fileId);
      if (!fileData)
        throw new Error(
          `PDF blob not found in storage for fileId: ${current.fileId}`,
        );

      console.log(
        `Processing ${current.pageCount} pages of PDF ${args.pdfId} via ${replicateConfig.model}`,
      );

      /* ---------- helper to OCR a single page ---------- */
      const processPage = async (pageNumber: number) => {
        const input = {
          pdf: fileData,
          page_number: 1,
          max_new_tokens:
            1024, // bump from 1024
          temperature: replicateConfig.temperature ?? 0.1,
        };

        const pageOutput = await runWithRetry({
          operation: () =>
            replicate.run(
              `${replicateConfig.model}:${replicateConfig.modelVersion}` as `${string}/${string}:${string}`,
              { input },
            ),
          maxRetries: replicateConfig.maxRetries,
          initialDelayMs: replicateConfig.retryDelayMs,
        });

        const text = extractOCRText(pageOutput);
        console.log(
          `‚úì page ${pageNumber} ‚Äì ${text.length.toLocaleString()} chars`,
        );
        return { pageNumber, text };
      };

      /* ---------- batched concurrency ---------- */
      const pageResults = [];
      for (let i = 0; i < current.pageCount; i += replicateConfig.batchSize) {
        const batch = Array.from(
          { length: Math.min(replicateConfig.batchSize, current.pageCount - i) },
          (_, j) => processPage(i + j + 1),
        );
        pageResults.push(...(await Promise.all(batch)));
      }

      /* ---------- aggregate + store ---------- */
      pageResults.sort((a, b) => a.pageNumber - b.pageNumber);
      const aggregatedText = pageResults
        .map((p) => `--- PAGE ${p.pageNumber} ---\n${p.text}`)
        .join("\n\n");

      await ctx.runMutation(internal.ocr.replicate.mutations.updateOcrResutls, {
        pdfId: args.pdfId,
        extractedText: aggregatedText,
        ocrStatus: "completed",
      });

      console.log(
        `Replicate OCR finished for PDF ${args.pdfId} (${aggregatedText.length.toLocaleString()} chars total)`,
      );
    } catch (error) {
      console.error(`Replicate OCR failed for PDF ${args.pdfId}:`, error);
      await ctx.runMutation(internal.ocr.replicate.mutations.updateOcrStatus, {
        pdfId: args.pdfId,
        ocrStatus: "failed",
      });
      throw error;
    }
  },
});

/* ------------------------------------------------------------------ *
 * 3. Single-page OCR fix ‚Äì use real page number + token bump
 * ------------------------------------------------------------------ */
export const processPageWithOcr = internalAction({
  args: { pageId: v.id("pages") },
  handler: async (
    ctx,
    args,
  ): Promise<{ success: boolean; pageId: Id<"pages">; provider: string }> => {
    try {
      const page = await ctx.runQuery(api.pdf.queries.getPdfPage, {
        pageId: args.pageId,
      });
      if (!page) throw new Error(`Page not found: ${args.pageId}`);

      await ctx.runMutation(
        internal.ocr.replicate.mutations.updatePageOcrStatus,
        { pageId: args.pageId, ocrStatus: "processing" },
      );

      const fileUrl = await ctx.storage.getUrl(page.fileId);
      if (!fileUrl) throw new Error(`File not found: ${page.fileId}`);

      const input = {
        pdf: fileUrl,
        page_number: 1, // ‚Üê FIXED
        max_new_tokens: 1024, 
      };

      const pageOutput = await runWithRetry({
        operation: () =>
          replicate.run(
            `${replicateConfig.model}:${replicateConfig.modelVersion}` as `${string}/${string}:${string}`,
            { input },
          ),
        maxRetries: replicateConfig.maxRetries,
        initialDelayMs: replicateConfig.retryDelayMs,
      });

      const extractedText = extractOCRText(pageOutput);

      await ctx.runMutation(
        internal.ocr.replicate.mutations.updatePageOcrResults,
        {
          pageId: args.pageId,
          extractedText,
          ocrStatus: "completed",
        },
      );

      console.log(
        `Replicate OCR done for page ${args.pageId} ‚Äì ${extractedText.length.toLocaleString()} chars`,
      );

      return { success: true, pageId: args.pageId, provider: "replicate" };
    } catch (error) {
      console.error(`Replicate OCR failed for page ${args.pageId}:`, error);
      await ctx.runMutation(
        internal.ocr.replicate.mutations.updatePageOcrStatus,
        { pageId: args.pageId, ocrStatus: "failed" },
      );
      throw error;
    }
  },
});



// File Path: convex/ocr/replicate/mutations.ts

// convex/ocr/replicate/mutations.ts
import { internalMutation } from "../../_generated/server";
import { v } from "convex/values";


export const updateOcrStatus = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    ocrStatus: v.union(v.literal("processing"), v.literal("failed")),
  },
  handler: async (ctx, args) => {
    const [row] = await ctx.db
      .query("replicateOcrResults")
      .withIndex("by_pdf_id", q => q.eq("pdfId", args.pdfId))
      .collect();
    if (row) {
      // update it
      await ctx.db.patch(row._id, {
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    } else {
      // or insert a new one
      await ctx.db.insert("replicateOcrResults", {
        pdfId: args.pdfId,
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    }
  },
});


export const updateOcrResutls = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    extractedText: v.string(),
    ocrStatus: v.string(),
  },
  handler: async (ctx, args) => {

    const [row] = await ctx.db
      .query("replicateOcrResults")
      .withIndex("by_pdf_id", q => q.eq("pdfId", args.pdfId))
      .collect();

    if (row) {
    await ctx.db.patch(row._id, {
      extractedText: args.extractedText,
      ocrStatus: "completed",
    });
    } else {
      throw new Error("Replicate OCR results not found for PDF ID: " + args.pdfId);
    }
  },
});





// convex/ocr/replicate/mutations.ts - Add to existing file

export const updatePageOcrStatus = internalMutation({
  args: {
    pageId: v.id("pages"),
    ocrStatus: v.union(v.literal("processing"), v.literal("failed")),
  },
  handler: async (ctx, args): Promise<void> => {
    const row = await ctx.db
      .query("replicatePageOcr")
      .withIndex("by_page_id", q => q.eq("pageId", args.pageId))
      .first();
      
    if (row) {
      // update existing row
      await ctx.db.patch(row._id, {
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    } else {
      // insert a new row
      await ctx.db.insert("replicatePageOcr", {
        pageId: args.pageId,
        ocrStatus: args.ocrStatus,
        processedAt: Date.now(),
      });
    }
  },
});

export const updatePageOcrResults = internalMutation({
  args: {
    pageId: v.id("pages"),
    extractedText: v.string(),
    ocrStatus: v.string(),
  },
  handler: async (ctx, args): Promise<void> => {
    const row = await ctx.db
      .query("replicatePageOcr")
      .withIndex("by_page_id", q => q.eq("pageId", args.pageId))
      .first();

    if (row) {
      await ctx.db.patch(row._id, {
        extractedText: args.extractedText,
        ocrStatus: "completed",
        processedAt: Date.now(),
      });
    } else {
      // In case the row doesn't exist yet
      await ctx.db.insert("replicatePageOcr", {
        pageId: args.pageId,
        extractedText: args.extractedText,
        ocrStatus: "completed",
        processedAt: Date.now(),
      });
    }
  },
});


// File Path: convex/ocr/replicate/queries.ts

// convex/ocr/replicate/queries.ts
import { query } from "../../_generated/server";
import { v } from "convex/values";

// Get Gemini OCR results specifically for a given PDF ID
export const getOcrResults = query({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args) => {
    const pdf = await ctx.db.get(args.pdfId);
    if (!pdf) {
      
      console.warn(`PDF not found in Replicate/getOcrResults query for ID: ${args.pdfId}`);
      return null; 
    }


    const ocrResults = await ctx.db
      .query("replicateOcrResults")
      .withIndex("by_pdf_id", (q) => q.eq("pdfId", args.pdfId))
      .first(); 

    return {
      pdf, 
      ocrResults, 
    };
  },
});


export const getOcrStatus = query({
  args: {
    pdfId: v.id("replicateOcrResults"),
  },
  handler: async (ctx, args) => {
    const ocrResults = await ctx.db.get(args.pdfId);
    if (!ocrResults) {
     throw new Error("PDF not found in Replicate OCR for ID: ${args.pdfId}");
    }
    return {ocrStatus: ocrResults.ocrStatus};
  },

  
});


export const getOcrByPdfId = query({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args) => {
    return  await ctx.db
    .query("replicateOcrResults")
    .withIndex("by_pdf_id", q => q.eq("pdfId", args.pdfId))
    .collect();
  }
})


export const getPageOcrResults = query({
  args: {
    pageId: v.id("pages"),
  },
  handler: async (ctx, args) => {
    const page = await ctx.db.get(args.pageId);
    if (!page) {
      console.warn(`Page not found in gemini/getPageOcrResults query for ID: ${args.pageId}`);
      return null;
    }

    const ocrResults = await ctx.db
      .query("replicatePageOcr")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .first();

    return {
      page,
      ocrResults,
    };
  },
});


// File Path: convex/pdf/actions.ts

// convex/pdf/actions.ts (new file)
import { internalAction } from "../_generated/server";
import { v } from "convex/values";
import { api, internal } from "../_generated/api";
import { splitPdf } from "../utils/pdfSplitter";
import { Id } from "../_generated/dataModel";

export const splitPdfIntoPages = internalAction({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args): Promise<Id<"pages">[]> => {
    // Skip if feature flag is not enabled


    try {
      // Get the PDF data
      const pdf = await ctx.runQuery(api.pdf.queries.getPdf, { pdfId: args.pdfId });
      if (!pdf) {
        throw new Error(`PDF not found for ID: ${args.pdfId}`);
      }

      // Fetch the PDF file
      const fileUrl = await ctx.storage.getUrl(pdf.fileId);
      
      
      if (!fileUrl) {
        throw new Error(`Could not get file URL for fileId: ${pdf.fileId}`);
      }

      // Download the PDF
      const response = await fetch(fileUrl);
      const pdfBuffer = await response.arrayBuffer();
      
      // Split into pages
      const pageBlobs = await splitPdf(pdfBuffer);
      console.log(`Split PDF into ${pageBlobs.length} pages`);
      
      // Store each page and create database entries
      const pageIds = [];
      
      for (let i = 0; i < pageBlobs.length; i++) {
        const pageNumber = i + 1;
        const pageBlob = pageBlobs[i];
        
        // Store the page in Convex storage
        const pageFileId = await ctx.storage.store(pageBlob);
        
        // Insert page record
        const pageId: Id<"pages"> = await ctx.runMutation(internal.pdf.mutations.savePdfPage, {
          pdfId: args.pdfId,
          pageNumber, 
          fileId: pageFileId,
          // Optional width/height could be added here if extracted
        });
        
        pageIds.push(pageId);
      }
      
      // Update the pageCount in the parent PDF if needed
      await ctx.runMutation(internal.pdf.mutations.updatePdfPageCount, {
        pdfId: args.pdfId,
        pageCount: pageBlobs.length
      });
      console.log(`Updated pageCount for PDF ${args.pdfId} to ${pageBlobs.length}`);
      console.log(`Page IDs: ${pageIds}`);
      return pageIds;
    } catch (error) {
      console.error(`Error in splitPdfIntoPages for PDF ${args.pdfId}:`, error);
      throw error;
    }
  },
});


// File Path: convex/pdf/mutations.ts

// convex/pdf/mutations.ts
import { internal } from "../_generated/api";
import { action, internalMutation, mutation } from "../_generated/server";
import { v } from "convex/values";
import { workflow } from "../workflow";
import { Id } from "../_generated/dataModel";


// Page by page mutations
// Public mutation: Called by the client after successfully uploading a file to storage.


export const savePdfMetadata = mutation({
  args: {
    fileId: v.string(),
    filename: v.string(),
    fileSize: v.number(),
    pageCount: v.number(),
  },
  handler: async (ctx, args) => {
 

    // Insert a new document into the 'pdfs' table
    const pdfId = await ctx.db.insert("pdfs", {
      fileId: args.fileId , // Store as StorageId type in DB
      filename: args.filename,
      fileSize: args.fileSize,
      pageCount: args.pageCount,
      uploadedAt: Date.now(), 
      status: "uploaded",


    });

    console.log(`Saved PDF metadata for ${args.filename}, ID: ${pdfId}`);
    await workflow.start(
      ctx,
      internal.workflow.ocrWorkflow.ocrWorkflow,
      { pdfId }
    );
    return pdfId;
  },
});







// Add this to the existing mutations file
export const savePdfPage = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    pageNumber: v.number(),
    fileId: v.string(),
    width: v.optional(v.number()),
    height: v.optional(v.number()),
  },
  handler: async (ctx, args): Promise<Id<"pages">> => {
    return await ctx.db.insert("pages", {
      pdfId: args.pdfId,
      pageNumber: args.pageNumber,
      fileId: args.fileId,
      width: args.width,
      height: args.height,
      createdAt: Date.now(),
    });
  },
});

export const updatePdfPageCount = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    pageCount: v.number(),
  },
  handler: async (ctx, args): Promise<void> => {
    const pdf = await ctx.db.get(args.pdfId);
    if (!pdf) {
      throw new Error(`PDF not found for ID: ${args.pdfId}`);
    }
    
    await ctx.db.patch(args.pdfId, {
      pageCount: args.pageCount,
    });
  },
});







// File Path: convex/pdf/queries.ts

// convex/pdf/queries.ts
import { Doc } from "../_generated/dataModel";
import { query } from "../_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import type { PdfPageInfo, OcrStatus } from "../../src/app/pdf/types";
import { asyncMap } from "modern-async";

// Get a list of all uploaded PDFs, potentially filtered and ordered.
export const getPdfList = query({
  args: {
    status: v.optional(v.string()),
    replicateStatus: v.optional(v.string()),
    filenameContains: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    let pdfsQuery = ctx.db.query("pdfs");

    // Apply filters dynamically based on provided arguments
    if (args.status) {
      pdfsQuery = pdfsQuery.filter((q) => q.eq(q.field("status"), args.status));
    }

    return await pdfsQuery.order("desc").collect();
  },
});

// Get a single PDF document by its Convex ID (_id).
export const getPdf = query({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args): Promise<Doc<"pdfs"> | null> => {
    const pdf = await ctx.db.get(args.pdfId);
    if (!pdf) {
      console.warn(`PDF with ID ${args.pdfId} not found.`);
      throw new Error(`PDF with ID ${args.pdfId} not found.`);
    }
    return pdf;
  },
});

export const getPdfPages = query({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args): Promise<Doc<"pages">[]> => {
    return await ctx.db
      .query("pages")
      .withIndex("byPdfIdAndPageNumber", (q) => q.eq("pdfId", args.pdfId))
      .collect();
  },
});

export const getPdfPage = query({
  args: {
    pageId: v.id("pages"),
  },
  handler: async (ctx, args): Promise<Doc<"pages"> | null> => {
    return await ctx.db.get(args.pageId);
  },
});

export const getPageWithOcrResults = query({
  args: {
    pageId: v.id("pages"),
  },
  handler: async (
    ctx,
    args
  ): Promise<
    | (Doc<"pages"> & {
        geminiOcr: Doc<"geminiPageOcr"> | null;
        replicateOcr: Doc<"replicatePageOcr"> | null;
        openaiCleaned: Doc<"openaiCleanedPage">[];
      })
    | null
  > => {
    const page = await ctx.db.get(args.pageId);
    if (!page) {
      return null;
    }

    const geminiOcr = await ctx.db
      .query("geminiPageOcr")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .first();

    const replicateOcr = await ctx.db
      .query("replicatePageOcr")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .first();

    const openaiCleaned = await ctx.db
      .query("openaiCleanedPage")
      .withIndex("by_page_id", (q) => q.eq("pageId", args.pageId))
      .collect();

    return {
      ...page,
      geminiOcr,
      replicateOcr,
      openaiCleaned,
    };
  },
});

// NEW: Get all pages for a PDF with status and snippet information
export const getPagesByPdf = query({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (ctx, args): Promise<PdfPageInfo[]> => {
    // Check if PDF exists
    const pdf = await ctx.db.get(args.pdfId);
    if (!pdf) {
      throw new ConvexError("PDF not found");
    }

    // Get all pages for this PDF, sorted by page number
    const pages = await ctx.db
      .query("pages")
      .withIndex("byPdfIdAndPageNumber", (q) => q.eq("pdfId", args.pdfId))
      .collect();

    // Map each page to PdfPageInfo
    const pageInfos: PdfPageInfo[] = await Promise.all(
      pages.map(async (page): Promise<PdfPageInfo> => {
        // Get Gemini OCR status
        const geminiOcr = await ctx.db
          .query("geminiPageOcr")
          .withIndex("by_page_id", (q) => q.eq("pageId", page._id))
          .first();

        // Get Replicate OCR status
        const replicateOcr = await ctx.db
          .query("replicatePageOcr")
          .withIndex("by_page_id", (q) => q.eq("pageId", page._id))
          .first();

        // Get cleaned text (prioritize OpenAI cleaned, fallback to raw OCR)
        let cleanedText: string | null = null;

        // First try OpenAI cleaned text
        const openaiCleaned = await ctx.db
          .query("openaiCleanedPage")
          .withIndex("by_page_id", (q) => q.eq("pageId", page._id))
          .filter((q) => q.eq(q.field("cleaningStatus"), "completed"))
          .first();

        if (openaiCleaned?.cleanedText) {
          cleanedText = openaiCleaned.cleanedText;
        } else {
          // Fallback to raw OCR text from either source
          if (geminiOcr?.extractedText) {
            cleanedText = geminiOcr.extractedText;
          } else if (replicateOcr?.extractedText) {
            cleanedText = replicateOcr.extractedText;
          }
        }

        // Create snippet (first 160 characters)
        let cleanedSnippet: string | null = null;
        if (cleanedText && cleanedText.length > 0) {
          cleanedSnippet =
            cleanedText.length > 160
              ? `${cleanedText.slice(0, 160)}‚Ä¶`
              : cleanedText;
        }

        return {
          pageId: page._id,
          pageNumber: page.pageNumber,
          geminiStatus: (geminiOcr?.ocrStatus as OcrStatus) || "pending",
          replicateStatus: (replicateOcr?.ocrStatus as OcrStatus) || "pending",
          cleanedSnippet,
        };
      })
    );

    // Return pages sorted by page number
    return pageInfos.sort((a, b) => a.pageNumber - b.pageNumber);
  },
});

export const getPdfByIds = query({
  args: {
    pdfIds: v.array(v.id("pdfs")),
  },
  handler: async (ctx, args) => {
    return await asyncMap(args.pdfIds, async (pdfId) => {
      const pdf = await ctx.db.get(pdfId);
      if (!pdf) {
        console.warn(`PDF with ID ${pdfId} not found`);
        return null;
      }
      return pdf;
    }).then((results) => results.filter((pdf) => pdf !== null));
  },
});



// File Path: convex/performOCR.ts

// Mutation that runs the internal action and returns the OCR content
import { internalAction, mutation } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";
import {
    GoogleGenAI,
    createPartFromUri,
    Part
} from "@google/genai";
import { gemini as geminiConfig, ocr as ocrConfig } from "./config";


export const exposeOCR = mutation({
    args: {
        url: v.string(),
    },
    handler: async (ctx, {url}) => {
        if (!url) {
            throw new Error('URL is required');
        }
        await ctx.scheduler.runAfter(0, internal.performOCR.performOCR, {url}) 
        return 
    },
});

export const performOCR = internalAction({
    args: {
        url: v.string(),
    },
    handler: async (ctx, args) => {

        const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });
        const pdfBuffer = await fetch(args.url)
            .then((response) => response.arrayBuffer());

        // Use the ArrayBuffer directly, no need to convert to Buffer
        const fileBlob = new Blob([pdfBuffer], { type: 'application/pdf' });

        const file = await ai.files.upload({
            file: fileBlob,
            config: {
                displayName: args.url,
            },
        });

        // Wait for the file to be processed.
        if (!file.name) {
            throw new Error('File name is undefined');
        }

        let getFile = await ai.files.get({ name: file.name });
        while (getFile.state === 'PROCESSING') {
            getFile = await ai.files.get({ name: file.name });
            console.log(`current file status: ${getFile.state}`);
            console.log('File is still processing, retrying in 5 seconds');
            await new Promise((resolve) => {
                setTimeout(resolve, geminiConfig.fileProcessingPollingIntervalMs);
            });
        }

        if (getFile.state === 'FAILED') {
            throw new Error('File processing failed.');
        }

        // Add the file to the contents.
        const content: (string | Part)[] = [
            ocrConfig.performOcrPrompt,
        ];

        if (file.uri && file.mimeType) {
            const fileContent = createPartFromUri(file.uri, file.mimeType);
            content.push(fileContent);
        }

        const response = await ai.models.generateContent({
            model: geminiConfig.model,
            contents: content,
        });

        return {
            text: response.text,
            url: args.url,
        };
    },
})



// File Path: convex/README.md

# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



// File Path: convex/schema.ts

// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { embedding as embeddingConfig } from "./config";

export default defineSchema({
  // Stores metadata about uploaded PDF files and tracks processing status for each provider.
  pdfs: defineTable({
    fileId: v.string(),
    filename: v.string(),
    fileSize: v.number(),
    pageCount: v.number(),
    uploadedAt: v.number(),
    status: v.string(),
    processingError: v.optional(v.string()),
  }),

  geminiOcrResults: defineTable({
    pdfId: v.id("pdfs"),
    extractedText: v.optional(v.string()),
    processedAt: v.number(),
    ocrStatus: v.union(
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed")
    ),
  }).index("by_pdf_id", ["pdfId"]),

  replicateOcrResults: defineTable({
    pdfId: v.id("pdfs"),
    extractedText: v.optional(v.string()),
    processedAt: v.number(),
    ocrStatus: v.union(
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed")
    ),
  }).index("by_pdf_id", ["pdfId"]),

  openaiOcrResults: defineTable({
    pdfId: v.id("pdfs"),
    cleanedText: v.string(),
    processedAt: v.number(),
    cleaningStatus: v.union(v.literal("started"), v.literal("completed")),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  }).index("by_pdf_id", ["pdfId"]),

  chunks: defineTable({
    pdfId: v.id("pdfs"),
    pageId: v.union(v.id("pages"), v.null()), // Add pageId field
    text: v.string(),
    embeddingId: v.union(v.id("embeddings"), v.null()),
  })
    .index("byPdfId", ["pdfId"])
    .index("byPageId", ["pageId"]) // ‚úÖ Consistent camelCase naming
    .index("byEmbeddingId", ["embeddingId"]),

  embeddings: defineTable({
    embedding: v.array(v.number()),
    chunkId: v.id("chunks"),
    pdfId: v.id("pdfs"),
    pageId: v.union(v.id("pages"), v.null()), // NEW: Add pageId field
  })
    .index("byChunkId", ["chunkId"])
    .index("byPdfId", ["pdfId"])
    .index("byPageId", ["pageId"]) // NEW: Add index for page-level queries
    .vectorIndex("byEmbedding", {
      vectorField: "embedding",
      dimensions: embeddingConfig.dimensions,
      filterFields: ["pdfId", "pageId"], // NEW: Add pageId to vector search filter fields
    }),

  // Add to schema.ts
  chatSessions: defineTable({
    sessionId: v.string(),
  }),

  messages: defineTable({
    sessionId: v.optional(v.string()),
    isUser: v.boolean(),
    text: v.string(),
    timestamp: v.number(),
  }).index("bySessionId", ["sessionId"]),

  ragSources: defineTable({
    sessionId: v.string(),
    pdfIds: v.array(v.id("pdfs")),
  })
    .index("bySessionId", ["sessionId"])
    .index("byPdfId", ["pdfIds"]),

  // New page by page schemas

  pages: defineTable({
    pdfId: v.id("pdfs"),
    pageNumber: v.number(),
    fileId: v.string(), // Convex storage ID for the page image/PDF
    width: v.optional(v.number()),
    height: v.optional(v.number()),
    createdAt: v.number(),
  })
    .index("byPdfId", ["pdfId"])
    .index("byPdfIdAndPageNumber", ["pdfId", "pageNumber"]),

  geminiPageOcr: defineTable({
    pageId: v.id("pages"),
    extractedText: v.optional(v.string()),
    ocrStatus: v.union(
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed")
    ),
    processedAt: v.number(),
  }).index("by_page_id", ["pageId"]),

  replicatePageOcr: defineTable({
    pageId: v.id("pages"),
    extractedText: v.optional(v.string()),
    ocrStatus: v.union(
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed")
    ),
    processedAt: v.number(),
  }).index("by_page_id", ["pageId"]),

  openaiCleanedPage: defineTable({
    pageId: v.id("pages"),
    cleanedText: v.string(),
    processedAt: v.number(),
    cleaningStatus: v.union(v.literal("started"), v.literal("completed")),
    source: v.union(v.literal("gemini"), v.literal("replicate")),
  })
    .index("by_page_id", ["pageId"])
    .index("by_page_source", ["pageId", "source"]), // Add this index
});



// File Path: convex/serve/serve.ts

// convex/serve/serve.ts - Enhanced vector search with page-aware filtering
import {
  internalAction,
  internalMutation,
  internalQuery,
  mutation,
  query,
} from "../_generated/server";
import { Id } from "../_generated/dataModel";
import { api, internal } from "../_generated/api";
import { v } from "convex/values";
import { embedTexts } from "../ingest/ingest";
import { asyncMap } from "modern-async";
import { streamText } from "ai";
import { openai } from "@ai-sdk/openai";

// Updated chunk type to include pageId and page metadata
interface EnhancedChunk {
  _id: Id<"chunks">;
  pdfId: Id<"pdfs">;
  text: string;
  embeddingId: Id<"embeddings"> | null;
  pageId: Id<"pages"> | null;
  pageNumber?: number;
  pdfFilename?: string;
}

// Enhanced citation metadata type
interface CitationMetadata {
  pdfId: Id<"pdfs">;
  pageId: Id<"pages"> | null;
  pageNumber: number | null;
  filename: string;
}

// Interface for message structure
interface Message {
  id?: Id<"messages">;
  isUser: boolean;
  text: string;
  sessionId?: string;
  timestamp: number;
}

// Type for search results
interface SearchResult {
  _id: Id<"embeddings">;
  _score: number;
}

// Interface for search results with data
interface SearchResultWithData {
  chunks: EnhancedChunk[];
  citations: CitationMetadata[];
}

// Main answer function implementing streaming with OpenAI and page citations
export const answer = internalAction({
  args: {
    sessionId: v.string(),
  },
  handler: async (ctx, { sessionId }): Promise<void> => {
    // Get messages and process the last user message
    const messages = (await ctx.runQuery(api.serve.serve.retrieveMessages, {
      sessionId,
    })) as Message[];

    // If no messages, return early
    if (!messages.length) {
      console.error("No messages found for session:", sessionId);
      return;
    }

    const lastUserMessage = messages.at(-1)!.text;
    console.log("Processing user message:", lastUserMessage);

    // Create a message placeholder for the bot response
    const messageId = await ctx.runMutation(
      internal.serve.serve.addBotMessage,
      {
        sessionId,
      }
    );

    try {
      // 1. Search for relevant documents using vector search
      const [embedding] = await embedTexts([lastUserMessage]);

      // **NEW: Page-aware vector search**
      const searchResults = (await ctx.vectorSearch(
        "embeddings",
        "byEmbedding",
        {
          vector: embedding,
          limit: 8, // Increased limit to get more results
        }
      )) as SearchResult[];

      if (searchResults.length === 0) {
        await ctx.runMutation(internal.serve.serve.updateBotMessage, {
          messageId,
          text: "I couldn't find any relevant information in the documents to answer your question. Could you please rephrase or ask about something covered in the uploaded documents?",
        });
        return;
      }

      // **NEW: Get enhanced chunks with page metadata**
      const relevantChunks = (await ctx.runQuery(
        internal.serve.serve.getEnhancedChunks,
        {
          embeddingIds: searchResults.map((result) => result._id),
        }
      )) as EnhancedChunk[];

      console.log(
        `Found ${relevantChunks.length} relevant chunks with page info`
      );

      // **NEW: Get citation metadata for all chunks**
      const citations = (await ctx.runQuery(
        internal.serve.serve.getCitationMetadata,
        {
          chunks: relevantChunks,
        }
      )) as CitationMetadata[];

      // Extract and update PDF IDs
      const relevantPdfs = relevantChunks.map(
        (chunk: EnhancedChunk) => chunk.pdfId
      );
      const uniqueRelevantPdfs = [...new Set(relevantPdfs)];

      await ctx.runMutation(internal.serve.serve.updateRagSources, {
        sessionId,
        pdfIds: uniqueRelevantPdfs,
      });

      // **NEW: Prepare context with citations**
      const contextWithCitations = relevantChunks.map((chunk, index) => {
        const citation = citations[index];
        const citationText = citation.pageNumber
          ? `(${citation.filename}, p. ${citation.pageNumber})`
          : `(${citation.filename})`; // Fallback for document-level chunks

        return {
          role: "system" as const,
          content: `Content from ${citationText}:\n\n${chunk.text}`,
        };
      });

      // Use OpenAI's streaming API via Vercel AI SDK
      const result = streamText({
        model: openai("gpt-4o"),
        messages: [
          {
            role: "system",
            content: `You are a helpful assistant that answers questions based on provided documents. 
            When you reference specific information, please include the citation in the format "(Filename.pdf, p. 5)" 
            or "(Filename.pdf)" if no specific page is referenced. 
            Keep your answers informative but concise. If the information comes from multiple pages or 
            documents, include multiple citations. The content you receive already includes citations, 
            so you can reference them in your response.`,
          },
          ...contextWithCitations,
          ...messages.map((msg: Message) => ({
            role: (msg.isUser ? "user" : "assistant") as "user" | "assistant",
            content: msg.text,
          })),
        ],
      });

      // Stream the response and update the message incrementally
      let fullText = "";
      for await (const textPart of result.textStream) {
        fullText += textPart;

        // Update the bot message as new text chunks arrive
        await ctx.runMutation(internal.serve.serve.updateBotMessage, {
          messageId,
          text: fullText,
        });
      }

      console.log("Completed streaming response with page citations");
    } catch (error) {
      console.error("Error in streaming response:", error);

      // Update with error message
      await ctx.runMutation(internal.serve.serve.updateBotMessage, {
        messageId,
        text: "Sorry, I encountered an error while generating a response. Please try again.",
      });

      throw error;
    }
  },
});

// **NEW: Enhanced getChunks query with page metadata**
export const getEnhancedChunks = internalQuery({
  args: {
    embeddingIds: v.array(v.id("embeddings")),
  },
  handler: async (ctx, { embeddingIds }): Promise<EnhancedChunk[]> => {
    return (await asyncMap(
      embeddingIds,
      async (embeddingId: Id<"embeddings">) => {
        // Get the chunk with its embedding
        const chunk = await ctx.db
          .query("chunks")
          .withIndex("byEmbeddingId", (q) => q.eq("embeddingId", embeddingId))
          .unique();

        if (!chunk) return null;

        // **NEW: Get page metadata if chunk has pageId**
        if (chunk.pageId) {
          const page = await ctx.db.get(chunk.pageId);
          const pdf = await ctx.db.get(chunk.pdfId);

          return {
            ...chunk,
            pageNumber: page?.pageNumber ?? null,
            pdfFilename: pdf?.filename ?? "Unknown Document",
          };
        }

        // For document-level chunks (pageId is null)
        const pdf = await ctx.db.get(chunk.pdfId);
        return {
          ...chunk,
          pageNumber: null,
          pdfFilename: pdf?.filename ?? "Unknown Document",
        };
      }
    ).then((results) =>
      results.filter((chunk) => chunk !== null)
    )) as EnhancedChunk[];
  },
});

// **NEW: Get citation metadata for chunks**
export const getCitationMetadata = internalQuery({
  args: {
    // Using any validator to allow system fields like _creationTime
    chunks: v.array(v.any()),
  },
  handler: async (ctx, { chunks }): Promise<CitationMetadata[]> => {
    return await asyncMap(
      chunks as EnhancedChunk[],
      async (chunk: EnhancedChunk): Promise<CitationMetadata> => {
        if (chunk.pageId) {
          // Page-level chunk
          const page = await ctx.db.get(chunk.pageId);
          const pdf = await ctx.db.get(chunk.pdfId);

          return {
            pdfId: chunk.pdfId,
            pageId: chunk.pageId,
            pageNumber: page?.pageNumber ?? null,
            filename: pdf?.filename ?? "Unknown Document",
          };
        } else {
          // Document-level chunk
          const pdf = await ctx.db.get(chunk.pdfId);

          return {
            pdfId: chunk.pdfId,
            pageId: null,
            pageNumber: null,
            filename: pdf?.filename ?? "Unknown Document",
          };
        }
      }
    );
  },
});

// **NEW: Page-aware vector search**
export const pageAwareVectorSearch = internalAction({
  args: {
    query: v.string(),
    pdfId: v.optional(v.id("pdfs")),
    pageId: v.optional(v.id("pages")),
    limit: v.optional(v.number()),
  },
  handler: async (
    ctx,
    { query, pdfId, pageId, limit = 16 }
  ): Promise<SearchResult[]> => {
    const [embedding] = await embedTexts([query]);

    // Different filter options based on provided parameters
    let searchOptions;

    if (pdfId && pageId) {
      // Both pdfId and pageId specified
      searchOptions = {
        vector: embedding,
        limit,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        filter: (q: any) => q.eq("pdfId", pdfId).eq("pageId", pageId),
      };
    } else if (pdfId) {
      // Only pdfId specified
      searchOptions = {
        vector: embedding,
        limit,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        filter: (q: any) => q.eq("pdfId", pdfId),
      };
    } else if (pageId) {
      // Only pageId specified
      searchOptions = {
        vector: embedding,
        limit,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        filter: (q: any) => q.eq("pageId", pageId),
      };
    } else {
      // No filters
      searchOptions = {
        vector: embedding,
        limit,
      };
    }

    // Perform vector search with appropriate options
    const searchResults = await ctx.vectorSearch(
      "embeddings",
      "byEmbedding",
      searchOptions
    );

    return searchResults as SearchResult[];
  },
});

// **NEW: Search in a specific document with page preference**
export const searchInDocument = internalAction({
  args: {
    query: v.string(),
    pdfId: v.id("pdfs"),
    preferPageLevel: v.optional(v.boolean()),
  },
  handler: async (
    ctx,
    { query, pdfId, preferPageLevel = true }
  ): Promise<SearchResultWithData> => {
    const [embedding] = await embedTexts([query]);

    const searchResults: SearchResult[] = [];

    if (preferPageLevel) {
      // Find page-specific results with non-null pageId
      const pageResults = await ctx.vectorSearch("embeddings", "byEmbedding", {
        vector: embedding,
        limit: 12,
        // Temporarily ignore type checking for Convex's vector filter API
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        filter: (q: any) => {
          // Use direct eq + not equal pattern that's compatible with Convex's API
          // This finds all entries where pdfId matches and pageId is not null
          return q.eq("pdfId", pdfId).not(q.eq("pageId", null));
        },
      });

      searchResults.push(...(pageResults as SearchResult[]));
    }

    // If not enough page results, add document-level results
    if (searchResults.length < 8) {
      // Find chunks where pageId is null
      const docResults = await ctx.vectorSearch("embeddings", "byEmbedding", {
        vector: embedding,
        limit: 8 - searchResults.length,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        filter: (q: any) => q.eq("pdfId", pdfId).eq("pageId", null),
      });

      searchResults.push(...(docResults as SearchResult[]));
    }

    // Get enhanced chunks with page metadata
    const enhancedChunks = (await ctx.runQuery(
      internal.serve.serve.getEnhancedChunks,
      {
        embeddingIds: searchResults.map((r) => r._id),
      }
    )) as EnhancedChunk[];

    // Get citation metadata
    const citations = (await ctx.runQuery(
      internal.serve.serve.getCitationMetadata,
      {
        chunks: enhancedChunks,
      }
    )) as CitationMetadata[];

    return {
      chunks: enhancedChunks,
      citations,
    };
  },
});

// Helper to format citations consistently
export const formatCitation = (citation: CitationMetadata): string => {
  if (citation.pageNumber !== null) {
    return `(${citation.filename}, p. ${citation.pageNumber})`;
  }
  return `(${citation.filename})`;
};

// Supporting mutation and query functions
export const updateRagSources = internalMutation({
  args: {
    sessionId: v.string(),
    pdfIds: v.array(v.id("pdfs")),
  },
  handler: async (ctx, { sessionId, pdfIds }) => {
    return await ctx.db.insert("ragSources", { sessionId, pdfIds });
  },
});

export const getRagSources = query({
  args: {
    sessionId: v.string(),
  },
  handler: async (ctx, { sessionId }) => {
    return await ctx.db
      .query("ragSources")
      .withIndex("bySessionId", (q) => q.eq("sessionId", sessionId))
      .collect();
  },
});

export const addBotMessage = internalMutation({
  args: {
    sessionId: v.string(),
  },
  handler: async (ctx, { sessionId }) => {
    return await ctx.db.insert("messages", {
      isUser: false,
      text: "",
      sessionId,
      timestamp: Date.now(),
    });
  },
});

export const updateBotMessage = internalMutation({
  args: {
    messageId: v.id("messages"),
    text: v.string(),
  },
  handler: async (ctx, { messageId, text }) => {
    return await ctx.db.patch(messageId, { text });
  },
});

export const saveMessage = mutation({
  args: {
    message: v.string(),
    sessionId: v.string(),
    isUser: v.boolean(),
  },
  handler: async (ctx, { message, sessionId, isUser }) => {
    await ctx.db.insert("messages", {
      text: message,
      sessionId,
      isUser,
      timestamp: Date.now(),
    });
    await ctx.scheduler.runAfter(0, internal.serve.serve.answer, {
      sessionId,
    });
  },
});

export const saveSessionId = mutation({
  args: {
    sessionId: v.string(),
  },
  handler: async (ctx, { sessionId }) => {
    return await ctx.db.insert("chatSessions", { sessionId });
  },
});

export const retrieveMessages = query({
  args: {
    sessionId: v.string(),
  },
  handler: async (ctx, { sessionId }) => {
    return await ctx.db
      .query("messages")
      .withIndex("bySessionId", (q) => q.eq("sessionId", sessionId))
      .collect();
  },
});



// File Path: convex/tsconfig.json

{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}



// File Path: convex/utils/cleaner.ts

import { streamText } from 'ai';
import { openai } from "@ai-sdk/openai";
import { openai as openaiConfig } from "../config";

/**
 * Pure OpenAI text cleaning utility using async generator pattern.
 * Streams cleaned text chunks and returns the full text when complete.
 * 
 * @param input - Raw text to be cleaned
 * @param model - OpenAI model to use (defaults to config value)
 * @returns AsyncGenerator that yields chunks and returns full text
 */
export async function* cleanTextWithOpenAI(
  input: string,
  model: "gpt-4o-mini" | "gpt-4-turbo" = openaiConfig.streamingModel as "gpt-4o-mini"
): AsyncGenerator<string, string, void> {
  let fullText = "";
  
  try {
    const { textStream } = await streamText({
      model: openai(model),
      system: openaiConfig.systemPrompt,
      prompt: input,
      temperature: openaiConfig.temperature,
    });
    
    for await (const chunk of textStream) {
      fullText += chunk;
      yield chunk;
    }
    
    return fullText;
  } catch (error) {
    // Re-throw errors to be handled by the HTTP handlers
    throw error;
  }
}


// File Path: convex/utils/geminiOcr.ts

import { GoogleGenAI } from "@google/genai";
import { gemini } from "../config";

const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

// Utility: convert ArrayBuffer ‚Üí base64 without Buffer
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  // `btoa` is available in the Convex V8 runtime
  return btoa(binary);
}

export default async function geminiPageOcr(pdfPageUrl: string) {
  console.log("Contacting Gemini ‚Ä¶");

  const arrayBuffer = await fetch(pdfPageUrl).then((r) => r.arrayBuffer());
  const base64 = arrayBufferToBase64(arrayBuffer);

  const contents = [
    { text: gemini.prompt },
    {
      inlineData: {
        mimeType: "application/pdf",
        data: base64,
      },
    },
  ];

  const response = await ai.models.generateContent({
    model: gemini.model,
    contents,
  });

  console.log(response.text);
  return response;
}


// File Path: convex/utils/pdfSplitter.ts

// convex/utils/pdfSplitter.ts
import { PDFDocument } from "pdf-lib";

export async function splitPdf(pdfBuffer: ArrayBuffer): Promise<Blob[]> {
  try {
    // Load the PDF
    const pdfDoc = await PDFDocument.load(pdfBuffer);
    const pageCount = pdfDoc.getPageCount();
    console.log(`Splitting PDF with ${pageCount} pages`);
    
    // Array to hold individual page PDFs
    const pageBlobs: Blob[] = [];
    
    // Process each page
    for (let i = 0; i < pageCount; i++) {
      // Create a new document with just this page
      const newDoc = await PDFDocument.create();
      const [page] = await newDoc.copyPages(pdfDoc, [i]);
      newDoc.addPage(page);
      
      // Convert to PDF bytes
      const pdfBytes = await newDoc.save();
      
      // Convert to Blob
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      pageBlobs.push(blob);
    }
    
    return pageBlobs;
  } catch (error) {
    console.error('Error splitting PDF:', error);
    throw new Error(`Failed to split PDF: ${error instanceof Error ? error.message : String(error)}`);
  }
}


// File Path: convex/utils/retry.ts

// convex/utils/retry.ts

/**
 * Utility for retrying operations with exponential backoff
 */
export async function runWithRetry<T>({
    operation,
    maxRetries = 5,
    initialDelayMs = 1000,
    maxDelayMs = 60000,
    onRetry,
  }: {
    operation: () => Promise<T>;
    maxRetries?: number;
    initialDelayMs?: number;
    maxDelayMs?: number;
    onRetry?: (attempt: number, error: Error, delayMs: number) => void;
  }): Promise<T> {
    let lastError: Error | null = null;
    let currentDelay = initialDelayMs;
  
    for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        
        // If this was the last attempt, rethrow the error
        if (attempt > maxRetries) {
          throw new Error(`Operation failed after ${maxRetries} retries: ${lastError.message}`);
        }
        
        // Calculate next delay with exponential backoff and jitter
        const jitter = Math.random() * 0.3 + 0.85; // Between 0.85 and 1.15
        currentDelay = Math.min(currentDelay * 2 * jitter, maxDelayMs);
        
        // Call optional callback
        if (onRetry) {
          onRetry(attempt, lastError, currentDelay);
        } else {
          console.log(`Attempt ${attempt} failed: ${lastError.message}. Retrying in ${currentDelay}ms...`);
        }
        
        // Wait before next attempt
        await new Promise(resolve => setTimeout(resolve, currentDelay));
      }
    }
    
    // This should never be reached due to the rethrow above, but TypeScript needs it
    throw lastError;
  }


// File Path: convex/utils/stream.ts


// diff --git a/convex/utils/streams.ts b/convex/utils/streams.ts
export function readableStreamFromIterable<T>(
  iterable: AsyncIterable<T> | Iterable<T>
): ReadableStream<Uint8Array> {
  const encoder = new TextEncoder();
  return new ReadableStream({
    async pull(controller) {
      for await (const chunk of iterable as AsyncIterable<T>) {
        controller.enqueue(
          typeof chunk === "string" ? encoder.encode(chunk) : (chunk as any)
        );
      }
      controller.close();
    },
  });
}



// File Path: convex/workflow/concatenateWorkflow.ts

// convex/workflows/concatenateWorkflow.ts
import { workflow } from "./index";
import { v } from "convex/values";
import { api, internal } from "../_generated/api";
import { action, internalMutation } from "../_generated/server";

export const concatenateAndEmbedWorkflow = workflow.define({
  args: {
    pdfId: v.id("pdfs"),
    preferredSource: v.optional(v.union(v.literal("gemini"), v.literal("replicate"))),
    retryCount: v.optional(v.number()),
  },
  handler: async (step, { pdfId, preferredSource, retryCount = 0 }): Promise<void> => {
    try {
      // 1. Get all pages for this PDF
      const pages = await step.runQuery(
        api.pdf.queries.getPdfPages,
        { pdfId },
        { name: `GetPDFPages-${pdfId}` }
      );
      
      if (!pages || pages.length === 0) {
        throw new Error(`No pages found for PDF ${pdfId}`);
      }
      
      console.log(`Found ${pages.length} pages for PDF ${pdfId}`);
      
      // 2. Check if all pages have cleaned text for at least one source
      let allPagesComplete = false;
      let completeSource: "gemini" | "replicate" | null = null;
      
      // Try the preferred source first if specified
      if (preferredSource) {
        const allComplete = await step.runQuery(
          internal.concatenate.queries.areAllPagesComplete,
          { pdfId, source: preferredSource },
          { name: `CheckCompletion-${preferredSource}-${pdfId}` }
        );
        
        if (allComplete) {
          allPagesComplete = true;
          completeSource = preferredSource;
        }
      }
      
      // If preferred source isn't complete or wasn't specified, check both sources
      if (!allPagesComplete) {
        // Try Gemini first (if it wasn't already the preferred source)
        if (preferredSource !== "gemini") {
          const geminiComplete = await step.runQuery(
            internal.concatenate.queries.areAllPagesComplete,
            { pdfId, source: "gemini" },
            { name: `CheckCompletion-gemini-${pdfId}` }
          );
          
          if (geminiComplete) {
            allPagesComplete = true;
            completeSource = "gemini";
          }
        }
        
        // Try Replicate if Gemini isn't complete
        if (!allPagesComplete && preferredSource !== "replicate") {
          const replicateComplete = await step.runQuery(
            internal.concatenate.queries.areAllPagesComplete,
            { pdfId, source: "replicate" },
            { name: `CheckCompletion-replicate-${pdfId}` }
          );
          
          if (replicateComplete) {
            allPagesComplete = true;
            completeSource = "replicate";
          }
        }
      }
      
      // If no source is fully complete, schedule another check after a delay
      if (!allPagesComplete || !completeSource) {
        console.log(`Not all pages complete for PDF ${pdfId}, will retry later (attempt ${retryCount})`);
        
        // Limit retry attempts to avoid infinite loops
        if (retryCount < 10) {
          // Schedule this same workflow to run again after 30 seconds
          // Instead of using sleep, we use the scheduler to run the workflow again
          await step.runAction(
            internal.concatenate.actions.recheckConcatenation,
            { 
              pdfId, 
              preferredSource,
              retryCount: retryCount + 1 
            },
            { 
              runAfter: 30000, // 30 seconds
              name: `RetryConcatenate-${pdfId}-${retryCount}` 
            }
          );
        } else {
          console.log(`Max retries reached for PDF ${pdfId}, giving up`);
        }
        
        return;
      }
      
      console.log(`All pages complete for PDF ${pdfId} using ${completeSource} source`);
      
      // 3. Concatenate the text for all pages in order
      const concatenatedText = await step.runQuery(
        internal.concatenate.queries.getConcatenatedText,
        { pdfId, source: completeSource },
        { name: `ConcatenateText-${pdfId}` }
      );
      
      // 4. Store the concatenated text
      await step.runMutation(
        internal.concatenate.mutations.saveConcatenatedText,
        { pdfId, source: completeSource, text: concatenatedText },
        { name: `SaveConcatenated-${pdfId}` }
      );
      
      // 5. Start the embedding process
      await step.runAction(
        api.ingest.ingest.chunkAndEmbed,
        { pdfId },
        { 
          retry: { maxAttempts: 3, initialBackoffMs: 1000, base: 2 },
          name: `ChunkAndEmbed-${pdfId}` 
        }
      );
      
      console.log(`Successfully processed PDF ${pdfId} with ${completeSource} source`);
    } catch (error) {
      console.error(`Error in concatenateAndEmbedWorkflow for PDF ${pdfId}:`, error);
      throw error;
    }
  },
});

export const startConcatenateWorkflow = internalMutation({
  args: {
    pdfId: v.id("pdfs"),
    preferredSource: v.optional(v.union(v.literal("gemini"), v.literal("replicate"))),
  },
  handler: async (ctx, args) => {
    await workflow.start(
      ctx,
      internal.workflow.concatenateWorkflow.concatenateAndEmbedWorkflow,
      { ...args, retryCount: 0 },
    );
  },
});


// File Path: convex/workflow/index.ts

// convex/workflows/index.ts
import { WorkflowManager } from "@convex-dev/workflow";
import { components } from "../_generated/api";

export const workflow = new WorkflowManager(components.workflow);


// File Path: convex/workflow/ocrWorkflow.ts

// convex/workflows/ocrWorkflow.ts
import { workflow } from "./index";
import { v } from "convex/values";
import { internal } from "../_generated/api";
import { Id } from "../_generated/dataModel";



export const ocrWorkflow = workflow.define({
  args: { pdfId: v.id("pdfs") },

  handler: async (
    step,
    { pdfId }
  ): Promise<{ pageIds: Id<"pages">[] }> => {
    // Split first
    const pageIds: Id<"pages">[] = await step.runAction(
      internal.pdf.actions.splitPdfIntoPages,
      { pdfId },
      { name: `SplitPDF-${pdfId}` }
    );

    // Spawn 2 ¬∑ N child workflows and DON'T await anything
    for (const pageId of pageIds) {
      // Start the Gemini workflow
      await step.runMutation(
        internal.workflow.providerWorkflow.kickoffproviderWorkflow,
        { pageId, provider: "gemini" },
        { name: `GeminiWF-${pageId}` }
      );

      await step.runMutation(
        internal.workflow.providerWorkflow.kickoffproviderWorkflow,
        { pageId, provider: "replicate" },
        { name: `ReplicateWF-${pageId}` }
      );
      
    }

    await step.runMutation(
      internal.workflow.concatenateWorkflow.startConcatenateWorkflow,
      { pdfId },
      { name: `StartConcatenate-${pdfId}` }
    );

    // Return immediately ‚Äî parent is done.
    return { pageIds };
  },
});




// File Path: convex/workflow/providerWorkflow.ts

// convex/workflows/providerWorkflow.ts
import { workflow } from "./index";
import { v } from "convex/values";
import { api, internal } from "../_generated/api";
import { internalMutation } from "../_generated/server";

export const providerWorkflow = workflow.define({
  args: {
    pageId: v.id("pages"),
    provider: v.union(v.literal("gemini"), v.literal("replicate")),
  },

  handler: async (step, { pageId, provider }): Promise<void> => {
    // 1. OCR with the chosen provider
    if (provider === "gemini") {
      await step.runAction(
        internal.ocr.gemini.actions.processPageWithOcr,
        { pageId },
        {
          retry: { maxAttempts: 3, initialBackoffMs: 1000, base: 2 },
          name: `GeminiOCR-Page-${pageId}`,
        }
      );
    } else {
      await step.runAction(
        internal.ocr.replicate.actions.processPageWithOcr,
        { pageId },
        {
          retry: { maxAttempts: 3, initialBackoffMs: 1000, base: 2 },
          name: `ReplicateOCR-Page-${pageId}`,
        }
      );
    }

    // 2. Clean the OCR results using the HTTP endpoint
    await step.runAction(
      internal.ocr.openai.actions.cleanPage,
      { pageId, source: provider },
      {
        retry: { maxAttempts: 3, initialBackoffMs: 2000, base: 2 },
        name: `CleanPageHTTP-${provider}-${pageId}`,
      }
    );

    // 3. NEW: Trigger chunkAndEmbed orchestration check
    await step.runAction(
      api.ingest.ingest.triggerChunkAndEmbedFromPageCleaning,
      { pageId, source: provider },
      {
        name: `TriggerOrchestration-${provider}-${pageId}`,
      }
    );
  },
});

export const kickoffproviderWorkflow = internalMutation({
  args: {
    pageId: v.id("pages"),
    provider: v.union(v.literal("gemini"), v.literal("replicate")),
  },
  handler: async (ctx, { pageId, provider }) => {
    await workflow.start(
      ctx,
      internal.workflow.providerWorkflow.providerWorkflow,
      { pageId, provider }
    );
  },
});



// File Path: convex/workflow/startWorkflow.ts

import { v } from "convex/values";
import { workflow } from "./index";
import { internal } from "../_generated/api";
import { Id } from "../_generated/dataModel";


const s = internal.pdf.actions;


// This is a workflow definition, not a mutation
export const ocrWorkflow = workflow.define({
  args: {
    pdfId: v.id("pdfs"),
  },
  handler: async (step, { pdfId }): Promise<{ success: boolean; pageIds: Id<"pages">[] }> => {
    try {
      // 1. Split the PDF into pages
      const pageIds: Id<"pages">[] = await step.runAction(
        s.splitPdfIntoPages,
        { pdfId }
      );
      
      // Rest of workflow implementation...
      
      return { success: true, pageIds };
    } catch (error) {
      console.error(`Error in OCRWorkflow for PDF ${pdfId}:`, error);
      throw error;
    }
  },
});


// File Path: convex/workflowOrch.ts

import { mutation } from "./_generated/server";

import { v } from "convex/values";
import { api, internal } from "./_generated/api";
import {  internalAction } from "./_generated/server";

export const workflowOrch = internalAction({
    args: {
        pdfId: v.id("pdfs"),
    },
    handler: async (ctx, args) => {
        
await Promise.allSettled([     
 ctx.scheduler.runAfter(0, api.ocr.gemini.actions.processPdfWithOcr, { pdfId: args.pdfId }),
 ctx.scheduler.runAfter(0, api.ocr.replicate.actions.processPdfWithOcr, { pdfId: args.pdfId })
])
  

  
    }
});


export const workflowOrchMutation = mutation({
    args: {
        pdfId: v.id("pdfs"),
    },
    handler: async (ctx, args) => {
        await ctx.scheduler.runAfter(0, internal.workflowOrch.workflowOrch, {pdfId: args.pdfId})
    }
})



// File Path: convex/_generated/api.d.ts

/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type * as api_ from "../api.js";
import type * as concatenate_actions from "../concatenate/actions.js";
import type * as concatenate_mutations from "../concatenate/mutations.js";
import type * as concatenate_queries from "../concatenate/queries.js";
import type * as config from "../config.js";
import type * as files_mutations from "../files/mutations.js";
import type * as files_queries from "../files/queries.js";
import type * as http from "../http.js";
import type * as ingest_ingest from "../ingest/ingest.js";
import type * as ocr_gemini_actions from "../ocr/gemini/actions.js";
import type * as ocr_gemini_mutations from "../ocr/gemini/mutations.js";
import type * as ocr_gemini_queries from "../ocr/gemini/queries.js";
import type * as ocr_openai_actions from "../ocr/openai/actions.js";
import type * as ocr_openai_mutations from "../ocr/openai/mutations.js";
import type * as ocr_openai_queries from "../ocr/openai/queries.js";
import type * as ocr_replicate_actions from "../ocr/replicate/actions.js";
import type * as ocr_replicate_mutations from "../ocr/replicate/mutations.js";
import type * as ocr_replicate_queries from "../ocr/replicate/queries.js";
import type * as pdf_actions from "../pdf/actions.js";
import type * as pdf_mutations from "../pdf/mutations.js";
import type * as pdf_queries from "../pdf/queries.js";
import type * as performOCR from "../performOCR.js";
import type * as serve_serve from "../serve/serve.js";
import type * as utils_cleaner from "../utils/cleaner.js";
import type * as utils_geminiOcr from "../utils/geminiOcr.js";
import type * as utils_pdfSplitter from "../utils/pdfSplitter.js";
import type * as utils_retry from "../utils/retry.js";
import type * as utils_stream from "../utils/stream.js";
import type * as workflow_concatenateWorkflow from "../workflow/concatenateWorkflow.js";
import type * as workflow_index from "../workflow/index.js";
import type * as workflow_ocrWorkflow from "../workflow/ocrWorkflow.js";
import type * as workflow_providerWorkflow from "../workflow/providerWorkflow.js";
import type * as workflow_startWorkflow from "../workflow/startWorkflow.js";
import type * as workflowOrch from "../workflowOrch.js";

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  api: typeof api_;
  "concatenate/actions": typeof concatenate_actions;
  "concatenate/mutations": typeof concatenate_mutations;
  "concatenate/queries": typeof concatenate_queries;
  config: typeof config;
  "files/mutations": typeof files_mutations;
  "files/queries": typeof files_queries;
  http: typeof http;
  "ingest/ingest": typeof ingest_ingest;
  "ocr/gemini/actions": typeof ocr_gemini_actions;
  "ocr/gemini/mutations": typeof ocr_gemini_mutations;
  "ocr/gemini/queries": typeof ocr_gemini_queries;
  "ocr/openai/actions": typeof ocr_openai_actions;
  "ocr/openai/mutations": typeof ocr_openai_mutations;
  "ocr/openai/queries": typeof ocr_openai_queries;
  "ocr/replicate/actions": typeof ocr_replicate_actions;
  "ocr/replicate/mutations": typeof ocr_replicate_mutations;
  "ocr/replicate/queries": typeof ocr_replicate_queries;
  "pdf/actions": typeof pdf_actions;
  "pdf/mutations": typeof pdf_mutations;
  "pdf/queries": typeof pdf_queries;
  performOCR: typeof performOCR;
  "serve/serve": typeof serve_serve;
  "utils/cleaner": typeof utils_cleaner;
  "utils/geminiOcr": typeof utils_geminiOcr;
  "utils/pdfSplitter": typeof utils_pdfSplitter;
  "utils/retry": typeof utils_retry;
  "utils/stream": typeof utils_stream;
  "workflow/concatenateWorkflow": typeof workflow_concatenateWorkflow;
  "workflow/index": typeof workflow_index;
  "workflow/ocrWorkflow": typeof workflow_ocrWorkflow;
  "workflow/providerWorkflow": typeof workflow_providerWorkflow;
  "workflow/startWorkflow": typeof workflow_startWorkflow;
  workflowOrch: typeof workflowOrch;
}>;
declare const fullApiWithMounts: typeof fullApi;

export declare const api: FilterApi<
  typeof fullApiWithMounts,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApiWithMounts,
  FunctionReference<any, "internal">
>;

export declare const components: {
  workflow: {
    journal: {
      load: FunctionReference<
        "query",
        "internal",
        { workflowId: string },
        {
          inProgress: Array<{
            _creationTime: number;
            _id: string;
            step: {
              args: any;
              argsSize: number;
              completedAt?: number;
              functionType: "query" | "mutation" | "action";
              handle: string;
              inProgress: boolean;
              name: string;
              runResult?:
                | { kind: "success"; returnValue: any }
                | { error: string; kind: "failed" }
                | { kind: "canceled" };
              startedAt: number;
              workId?: string;
            };
            stepNumber: number;
            workflowId: string;
          }>;
          journalEntries: Array<{
            _creationTime: number;
            _id: string;
            step: {
              args: any;
              argsSize: number;
              completedAt?: number;
              functionType: "query" | "mutation" | "action";
              handle: string;
              inProgress: boolean;
              name: string;
              runResult?:
                | { kind: "success"; returnValue: any }
                | { error: string; kind: "failed" }
                | { kind: "canceled" };
              startedAt: number;
              workId?: string;
            };
            stepNumber: number;
            workflowId: string;
          }>;
          logLevel: "DEBUG" | "TRACE" | "INFO" | "REPORT" | "WARN" | "ERROR";
          ok: boolean;
          workflow: {
            _creationTime: number;
            _id: string;
            args: any;
            generationNumber: number;
            logLevel?: any;
            name?: string;
            onComplete?: { context?: any; fnHandle: string };
            runResult?:
              | { kind: "success"; returnValue: any }
              | { error: string; kind: "failed" }
              | { kind: "canceled" };
            startedAt?: any;
            state?: any;
            workflowHandle: string;
          };
        }
      >;
      startStep: FunctionReference<
        "mutation",
        "internal",
        {
          generationNumber: number;
          name: string;
          retry?:
            | boolean
            | { base: number; initialBackoffMs: number; maxAttempts: number };
          schedulerOptions?: { runAt?: number } | { runAfter?: number };
          step: {
            args: any;
            argsSize: number;
            completedAt?: number;
            functionType: "query" | "mutation" | "action";
            handle: string;
            inProgress: boolean;
            name: string;
            runResult?:
              | { kind: "success"; returnValue: any }
              | { error: string; kind: "failed" }
              | { kind: "canceled" };
            startedAt: number;
            workId?: string;
          };
          workflowId: string;
          workpoolOptions?: {
            defaultRetryBehavior?: {
              base: number;
              initialBackoffMs: number;
              maxAttempts: number;
            };
            logLevel?: "DEBUG" | "TRACE" | "INFO" | "REPORT" | "WARN" | "ERROR";
            maxParallelism?: number;
            retryActionsByDefault?: boolean;
          };
        },
        {
          _creationTime: number;
          _id: string;
          step: {
            args: any;
            argsSize: number;
            completedAt?: number;
            functionType: "query" | "mutation" | "action";
            handle: string;
            inProgress: boolean;
            name: string;
            runResult?:
              | { kind: "success"; returnValue: any }
              | { error: string; kind: "failed" }
              | { kind: "canceled" };
            startedAt: number;
            workId?: string;
          };
          stepNumber: number;
          workflowId: string;
        }
      >;
    };
    workflow: {
      cancel: FunctionReference<
        "mutation",
        "internal",
        { workflowId: string },
        null
      >;
      cleanup: FunctionReference<
        "mutation",
        "internal",
        { workflowId: string },
        boolean
      >;
      complete: FunctionReference<
        "mutation",
        "internal",
        {
          generationNumber: number;
          now: number;
          runResult:
            | { kind: "success"; returnValue: any }
            | { error: string; kind: "failed" }
            | { kind: "canceled" };
          workflowId: string;
        },
        null
      >;
      create: FunctionReference<
        "mutation",
        "internal",
        {
          maxParallelism?: number;
          onComplete?: { context?: any; fnHandle: string };
          validateAsync?: boolean;
          workflowArgs: any;
          workflowHandle: string;
          workflowName: string;
        },
        string
      >;
      getStatus: FunctionReference<
        "query",
        "internal",
        { workflowId: string },
        {
          inProgress: Array<{
            _creationTime: number;
            _id: string;
            step: {
              args: any;
              argsSize: number;
              completedAt?: number;
              functionType: "query" | "mutation" | "action";
              handle: string;
              inProgress: boolean;
              name: string;
              runResult?:
                | { kind: "success"; returnValue: any }
                | { error: string; kind: "failed" }
                | { kind: "canceled" };
              startedAt: number;
              workId?: string;
            };
            stepNumber: number;
            workflowId: string;
          }>;
          logLevel: "DEBUG" | "TRACE" | "INFO" | "REPORT" | "WARN" | "ERROR";
          workflow: {
            _creationTime: number;
            _id: string;
            args: any;
            generationNumber: number;
            logLevel?: any;
            name?: string;
            onComplete?: { context?: any; fnHandle: string };
            runResult?:
              | { kind: "success"; returnValue: any }
              | { error: string; kind: "failed" }
              | { kind: "canceled" };
            startedAt?: any;
            state?: any;
            workflowHandle: string;
          };
        }
      >;
    };
  };
};



// File Path: convex/_generated/api.js

/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi, componentsGeneric } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
export const components = componentsGeneric();



// File Path: convex/_generated/dataModel.d.ts

/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;



// File Path: convex/_generated/server.d.ts

/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  AnyComponents,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
  FunctionReference,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

type GenericCtx =
  | GenericActionCtx<DataModel>
  | GenericMutationCtx<DataModel>
  | GenericQueryCtx<DataModel>;

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;



// File Path: convex/_generated/server.js

/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
  componentsGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;



// File Path: next-env.d.ts

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.



// File Path: next.config.ts

/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    useLightningcss: false,  // ‚Üê turn off the Rust-based pipeline
  },
};

module.exports = nextConfig;



// File Path: package.json

{
  "name": "documents",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.20",
    "@convex-dev/workflow": "^0.2.3",
    "@google/genai": "^0.8.0",
    "@google/generative-ai": "^0.24.0",
    "@langchain/core": "^0.3.45",
    "@mdxeditor/editor": "^3.30.0",
    "@radix-ui/react-accordion": "^1.2.10",
    "@radix-ui/react-alert-dialog": "^1.1.11",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-toggle": "^1.1.6",
    "@radix-ui/react-tooltip": "^1.2.6",
    "@tailwindcss/typography": "^0.5.16",
    "@types/lodash.debounce": "^4.0.9",
    "ai": "^4.3.10",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.23.0",
    "langchain": "^0.3.22",
    "lightningcss-win32-x64-msvc": "^1.29.3",
    "lodash.debounce": "^4.0.8",
    "lucide": "^0.488.0",
    "lucide-react": "^0.488.0",
    "modern-async": "^2.0.4",
    "motion": "^12.9.4",
    "next": "15.2.5",
    "openai": "^4.94.0",
    "pdf-lib": "^1.17.1",
    "pdfjs-dist": "^3.11.174",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.3.8",
    "react-markdown": "^10.1.0",
    "react-pdf": "^9.2.1",
    "replicate": "^1.0.1",
    "tailwind-merge": "^3.2.0",
    "tailwindcss": "^3.3.3",
    "tailwindcss-animate": "^1.0.7",
    "zustand": "^5.0.4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.5",
    "postcss": "^8.5.3",
    "tw-animate-css": "^1.2.8",
    "typescript": "^5"
  }
}



// File Path: project-structure.txt

[dir]  .next/
[dir]  .next/cache/
[dir]  .next/cache/images/
[dir]  .next/cache/images/khLohs3sU48fkkOJb_AvcN8eWmQoTkPIgFLYyXIhkZM/
[dir]  .next/cache/images/lkGTckl_N0rZoyS3H7X0-JsbjylLjH72iuON0K_PVpk/
[dir]  .next/cache/images/MbtBF8NAd-kiJxVMwp9ZDgH3woFCaIb4HxhXot24Uz4/
[dir]  .next/cache/images/QFnq_OyjVY1lWN_xIqvolLj0Q6P2SkaVZP9z_e-2ze4/
[dir]  .next/cache/images/qQv0Z5n05_y7x4Nkcvp12IqyGuizoM8JT85YvsVHYVA/
[dir]  .next/cache/swc/
[dir]  .next/cache/swc/plugins/
[dir]  .next/cache/swc/plugins/v7_windows_x86_64_8.0.0/
[dir]  .next/cache/webpack/
[dir]  .next/cache/webpack/client-development/
[dir]  .next/cache/webpack/client-development-fallback/
[dir]  .next/cache/webpack/server-development/
[dir]  .next/server/
[dir]  .next/server/app/
[dir]  .next/server/app/_not-found/
[dir]  .next/server/app/chat/
[dir]  .next/server/app/pdf/
[dir]  .next/server/app/pdf/[storageId]/
[dir]  .next/server/app/pdf/[storageId]/pages/
[dir]  .next/server/vendor-chunks/
[dir]  .next/static/
[dir]  .next/static/chunks/
[dir]  .next/static/chunks/app/
[dir]  .next/static/chunks/app/_not-found/
[dir]  .next/static/chunks/app/chat/
[dir]  .next/static/chunks/app/pdf/
[dir]  .next/static/chunks/app/pdf/[storageId]/
[dir]  .next/static/chunks/app/pdf/[storageId]/pages/
[dir]  .next/static/css/
[dir]  .next/static/css/app/
[dir]  .next/static/development/
[dir]  .next/static/media/
[dir]  .next/static/webpack/
[dir]  .next/static/webpack/app/
[dir]  .next/static/webpack/app/chat/
[dir]  .next/static/webpack/app/pdf/
[dir]  .next/static/webpack/app/pdf/[storageId]/
[dir]  .next/static/webpack/app/pdf/[storageId]/pages/
[dir]  .next/types/
[dir]  .next/types/app/
[dir]  .next/types/app/chat/
[dir]  .next/types/app/pdf/
[dir]  .next/types/app/pdf/[storageId]/
[dir]  .next/types/app/pdf/[storageId]/pages/
[dir]  convex/
[dir]  convex/_generated/
[dir]  convex/concatenate/
[dir]  convex/files/
[dir]  convex/ingest/
[dir]  convex/ocr/
[dir]  convex/ocr/gemini/
[dir]  convex/ocr/openai/
[dir]  convex/ocr/replicate/
[dir]  convex/pdf/
[dir]  convex/serve/
[dir]  convex/utils/
[dir]  convex/workflow/
[dir]  public/
[dir]  src/
[dir]  src/app/
[dir]  src/app/chat/
[dir]  src/app/components/
[dir]  src/app/pdf/
[dir]  src/app/pdf/[storageId]/
[dir]  src/app/pdf/[storageId]/components/
[dir]  src/app/pdf/[storageId]/hooks/
[dir]  src/app/pdf/[storageId]/pages/
[dir]  src/app/pdf/[storageId]/types/
[dir]  src/app/pdf/[storageId]/utils/
[dir]  src/app/pdf/hooks/
[dir]  src/app/pdf/pages/
[dir]  src/components/
[dir]  src/components/ui/
[dir]  src/lib/
[dir]  src/services/
[dir]  src/store/
[dir]  src/utils/
[file] .env
[file] .env.local
[file] .gitignore
[file] components.json
[file] copy_content.sh
[file] eslint.config.mjs
[file] next-env.d.ts
[file] next.config.ts
[file] package-lock.json
[file] package.json
[file] postcss.config.mjs
[file] project_contents.txt
[file] project-structure.txt
[file] README.md
[file] tailwind.config.ts
[file] tsconfig.json
[file] tsconfig.tsbuildinfo 


// File Path: project_contents.txt




// File Path: README.md

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.



// File Path: src/app/chat/layout.tsx

export default function ChatLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="h-screen">
      {children}
    </div>
  );
} 


// File Path: src/app/chat/page.tsx

// src/app/chat/page.tsx - Updated with citation handling
"use client";

import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import ChatInput from "../components/Chatnput";
import ChatMessages from "../components/ChatMessages";
import { Trash2 } from "lucide-react";
import Sources from "../components/Sources";
import PDFViewer, { PDFViewerHandle } from "../components/PDFViewer";
import ChatHeader from "../components/ChatHeader";
import { useRouter } from "next/navigation";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";

interface PDF {
  _id: Id<"pdfs">;
  _creationTime: number;
  processingError?: string;
  fileId: Id<"_storage">; // Updated to use proper storage ID type
  filename: string;
  fileSize: number;
  pageCount: number;
  uploadedAt: number;
  status: string;
}

// Polyfill for crypto.randomUUID
const generateUUID = () => {
  try {
    return crypto.randomUUID();
  } catch {
    // Fallback implementation if randomUUID is not available
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function (c) {
        const r = (Math.random() * 16) | 0;
        const v = c === "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      }
    );
  }
};

export default function Chat() {
  const [input, setInput] = useState("");
  const [sessionId, setSessionId] = useState<string>("");
  const [pdfUrl, setPdfUrl] = useState<string>("");
  const [selectedFilename, setSelectedFilename] = useState<string>("");
  const [selectedFileId, setSelectedFileId] = useState<Id<"_storage"> | null>(
    null
  ); // Updated type
  const router = useRouter();

  // Reference to PDFViewer for page navigation
  const pdfViewerRef = useRef<PDFViewerHandle>(null);

  // Fetch data using Convex queries at the component level
  const sourcesData = useQuery(api.serve.serve.getRagSources, { sessionId });
  const pdfIds = sourcesData?.[sourcesData?.length - 1]?.pdfIds ?? [];
  const pdfsInfo = useQuery(api.pdf.queries.getPdfByIds, { pdfIds }) as
    | PDF[]
    | undefined;
  const fileUrl = useQuery(
    api.files.queries.getFileDownloadUrl,
    selectedFileId ? { fileId: selectedFileId } : "skip"
  );

  // Update PDF URL when fileUrl changes
  useEffect(() => {
    if (fileUrl) {
      setPdfUrl(fileUrl);
    }
  }, [fileUrl]);

  // Initialize sessionId after component mounts to avoid SSR issues
  useEffect(() => {
    setSessionId(generateUUID());
  }, []);

  const clearChat = () => {
    setSessionId(generateUUID());
    setPdfUrl("");
    setSelectedFilename("");
    setSelectedFileId(null);
    router.refresh();
  };

  // Handle citation clicks
  const handleCitationClick = (filename: string, pageNumber?: number) => {
    try {
      if (!pdfsInfo) return;

      const targetPdf = pdfsInfo.find((pdf) => pdf?.filename === filename);

      if (!targetPdf) {
        console.warn(`Could not find PDF with filename: ${filename}`);
        return;
      }

      setSelectedFileId(targetPdf.fileId);
      setSelectedFilename(filename);

      // Navigate to the specific page if pageNumber is provided
      if (pageNumber && pdfViewerRef.current) {
        pdfViewerRef.current.goToPage(pageNumber);
      }
    } catch (error) {
      console.error("Error handling citation click:", error);
    }
  };

  // Handle page navigation from Sources component
  const handlePageNavigate = (pageNumber: number) => {
    if (pdfViewerRef.current) {
      pdfViewerRef.current.goToPage(pageNumber);
    }
  };

  return (
    <div
      className="min-h-[calc(100vh-4rem)] md:h-full w-full"
      style={{
        backgroundImage: 'url("/background.png")',
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        backgroundAttachment: "fixed",
      }}
    >
      <div className="flex flex-col md:flex-row h-auto md:h-full">
        <PDFViewer
          ref={pdfViewerRef}
          pdfUrl={pdfUrl}
          fitToWidth={true}
          maxScale={2.0}
        />
        <div className="w-full md:w-full p-3 flex flex-col h-auto md:h-[95%]">
          <div className="bg-white/10 backdrop-blur-md shadow-lg rounded-2xl p-3 border border-white/20 flex-grow flex flex-col overflow-auto max-h-[80vh] md:max-h-none">
            <ChatHeader />
            <ChatMessages
              sessionId={sessionId}
              onCitationClick={handleCitationClick}
            />
            <Sources
              sessionId={sessionId}
              setPdfUrl={setPdfUrl}
              onPageNavigate={handlePageNavigate}
            />

            <div className="flex items-center gap-2 mb-1 justify-center">
              <div className="max-w-[600px] flex-1">
                <ChatInput
                  input={input}
                  setInput={setInput}
                  setMessages={() => {}}
                  sessionId={sessionId}
                />
              </div>
              <Button
                onClick={clearChat}
                variant="destructive"
                size="sm"
                className="bg-emerald-950 hover:bg-emerald-600"
                title="ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´Ÿá"
              >
                <Trash2 size={18} />
              </Button>
            </div>
          </div>
        </div>
      </div>

      {/* Display current PDF filename if available */}
      {selectedFilename && (
        <div className="fixed bottom-4 left-4 bg-emerald-950/90 backdrop-blur-sm text-white text-xs px-3 py-1 rounded-full">
          Viewing: {selectedFilename}
        </div>
      )}
    </div>
  );
}



// File Path: src/app/components/Background.tsx

import React from 'react'

function Background() {
  return (
    <div 
      className="flex flex-col md:flex-row h-screen"
      style={{
        backgroundImage: 'url("/background.png")',
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat'
      }}
    />
    
  )
}

export default Background


// File Path: src/app/components/ChatHeader.tsx

import React from 'react';

export default function ChatHeader() {
  return (
    <div className="mb-4 text-right">
      <h2 className="text-2xl font-semibold text-white">ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©</h2>
      <p className="text-white/70 text-sm">
          ÿßÿ∑ÿ±ÿ≠ ÿ≥ÿ§ÿßŸÑŸÉ Ÿàÿ≥ÿ£ÿ¨ÿØ ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
      </p>
    </div>
  );
}


// File Path: src/app/components/ChatMessage.tsx

// src/app/components/ChatMessage.tsx - Updated with citation support and RTL for Arabic
"use client";

import React from "react";
import ReactMarkdown from "react-markdown";
import TypingIndicator from "./TypingIndicator";
import { ProcessedText } from "./CitationLink";

interface ChatMessageProps {
  message: string;
  isUser: boolean;
  onCitationClick?: (filename: string, pageNumber?: number) => void;
}

// Helper function to detect if text contains Arabic
const containsArabic = (text: string): boolean => {
  return /[\u0600-\u06FF]/.test(text);
};

export default function ChatMessage({
  message,
  isUser,
  onCitationClick = () => {},
}: ChatMessageProps) {
  // Detect if message contains Arabic
  const isRTL = containsArabic(message);

  return (
    <div className={`flex justify-${isUser ? "end" : "start"} mb-4`}>
      <div
        className={`max-w-[80%] rounded-2xl px-4 py-2 ${
          isUser
            ? "bg-emerald-600 text-white shadow-md"
            : "bg-white/10 backdrop-blur-md border border-white/20 text-white shadow-md "
        }`}
        style={{ direction: isRTL ? "rtl" : "ltr" }}
      >
        {message === "" ? (
          <TypingIndicator />
        ) : (
          <div
            className={`prose prose-invert prose-sm max-w-none break-words text-lg ${
              isUser ? "" : "prose-headings:text-white prose-a:text-blue-300"
            }`}
            style={{
              textAlign: isRTL ? "right" : "left",
              fontFamily: isRTL ? "'Noto Sans Arabic', sans-serif" : "inherit",
            }}
          >
            {isUser ? (
              // User messages don't need citation processing
              <ReactMarkdown>{message}</ReactMarkdown>
            ) : (
              // Bot messages need citation processing
              <ReactMarkdown
                components={{
                  // Custom component for text nodes to process citations
                  text: ({ children }) => (
                    <ProcessedText
                      text={children?.toString() || ""}
                      onCitationClick={onCitationClick}
                    />
                  ),
                  // Keep other markdown components as they are
                  p: ({ children }) => (
                    <p>
                      {React.Children.map(children, (child) =>
                        typeof child === "string" ? (
                          <ProcessedText
                            text={child}
                            onCitationClick={onCitationClick}
                          />
                        ) : (
                          child
                        )
                      )}
                    </p>
                  ),
                }}
              >
                {message}
              </ReactMarkdown>
            )}
          </div>
        )}
        <p
          className="text-xs mt-1 text-emerald-200"
          style={{ textAlign: isRTL ? "left" : "right" }}
        >
          {new Date().toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
          })}
        </p>
      </div>
    </div>
  );
}



// File Path: src/app/components/ChatMessages.tsx

// src/app/components/ChatMessages.tsx - Updated with citation support
"use client";
import { useEffect, useRef } from "react";
import ChatMessage from "./ChatMessage";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";

interface ChatMessagesProps {
  sessionId: string;
  onCitationClick?: (filename: string, pageNumber?: number) => void;
}

export default function ChatMessages({
  sessionId,
  onCitationClick = () => {},
}: ChatMessagesProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);

  const retrieveMessages = useQuery(api.serve.serve.retrieveMessages, {
    sessionId,
  });

  const messages = retrieveMessages;

  // Function to check if user is near bottom
  const isNearBottom = () => {
    if (!chatContainerRef.current) return true;

    const container = chatContainerRef.current;
    const threshold = 100; // pixels from bottom to trigger auto-scroll
    const distanceFromBottom =
      container.scrollHeight - container.scrollTop - container.clientHeight;

    return distanceFromBottom <= threshold;
  };

  // Scroll to bottom whenever messages change, but only if near bottom
  useEffect(() => {
    if (isNearBottom()) {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }
  }, [messages]);

  return (
    <div
      ref={chatContainerRef}
      className="flex-grow overflow-y-auto mb-4 space-y-4 scrollbar-thin scrollbar-thumb-white/20 scrollbar-track-transparent pr-2"
    >
      {/* Welcome message */}
      <div className="flex justify-start">
        <div className="bg-white/20 text-white rounded-2xl px-4 py-2">
          <p className="text-right">
            ŸÖÿ±ÿ≠ÿ®ÿßŸã! ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉÿü ÿßÿ∑ÿ±ÿ≠ ÿ≥ÿ§ÿßŸÑÿßŸã Ÿàÿ≥ÿ£ÿ≥ÿßÿπÿØŸÉ ŸÅŸä ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ
            ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©.
          </p>
        </div>
      </div>

      {/* Messages with citation support */}
      {messages &&
        messages.map((message, index) => (
          <ChatMessage
            key={index}
            message={message.text}
            isUser={message.isUser}
            onCitationClick={onCitationClick}
          />
        ))}

      {/* Invisible element for scroll reference */}
      <div ref={messagesEndRef} />
    </div>
  );
}



// File Path: src/app/components/Chatnput.tsx

"use client"
import { Send } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { api } from '../../../convex/_generated/api';
import { useMutation } from 'convex/react';
import { Id } from '../../../convex/_generated/dataModel';
import { ChangeEvent, KeyboardEvent } from 'react';

export default function ChatInput({ input, setInput, setMessages, sessionId }: 
  { 
    input: string, 
    setInput: (input: string) => void, 
    setMessages: React.Dispatch<React.SetStateAction<string[]>>, 
    sessionId: string 
  }) {

  const saveMessage = useMutation(api.serve.serve.saveMessage);

  const handleSendMessage = async (): Promise<void> => {
    if (input.trim() === '') return;
    
    // Add user message to the chat
    const userMessage = input;
    
    setMessages(prevMessages => [...prevMessages, userMessage]);
    await saveMessage({
      message: userMessage,
      sessionId: sessionId as Id<"chatSessions">,
      isUser: true,
    });
    
    setInput('');
  }
    
  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>): void => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  return (
    <div className="w-full relative">
      <Textarea
        placeholder="ÿßŸÉÿ™ÿ® ÿ≥ÿ§ÿßŸÑŸÉ ŸáŸÜÿß..."
        className="w-full bg-white/10 text-white placeholder-white/50 rounded-xl pl-12 pr-4 focus:outline-none focus:ring-2 focus:ring-emerald-500 min-h-[44px] py-2 resize-none"
        dir="rtl"
        value={input}
        onChange={(e: ChangeEvent<HTMLTextAreaElement>) => setInput(e.target.value)}
        onKeyDown={handleKeyDown}
        rows={3}
      />
      <div className="absolute left-3 inset-y-0 flex items-center">
        <Button variant="ghost"
          className="p-1.5 rounded-full bg-emerald-600 text-white h-8 w-8 flex items-center justify-center"
          onClick={handleSendMessage}
          disabled={input.trim() === ''}
        >
          <Send size={15} />
        </Button>
      </div>
    </div>
  );
}


// File Path: src/app/components/CitationLink.tsx

// src/app/components/CitationLink.tsx
"use client";

import React from "react";
import { parseCitations, ParsedCitation } from "@/utils/citationParser";

interface CitationLinkProps {
  citation: ParsedCitation;
  onClick: (filename: string, pageNumber?: number) => void;
  className?: string;
}

export function CitationLink({
  citation,
  onClick,
  className = "",
}: CitationLinkProps) {
  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    onClick(citation.filename, citation.pageNumber || undefined);
  };

  return (
    <button
      onClick={handleClick}
      className={`text-emerald-400 hover:text-emerald-300 underline cursor-pointer transition-colors ${className}`}
      title={`Go to ${citation.filename}${citation.pageNumber ? `, page ${citation.pageNumber}` : ""}`}
    >
      {citation.fullCitation}
    </button>
  );
}

interface ProcessedTextProps {
  text: string;
  onCitationClick: (filename: string, pageNumber?: number) => void;
  className?: string;
}

export function ProcessedText({
  text,
  onCitationClick,
  className = "",
}: ProcessedTextProps) {
  const citations = parseCitations(text);

  if (citations.length === 0) {
    return <span className={className}>{text}</span>;
  }

  // Split text into parts and citations
  const parts: Array<{
    type: "text" | "citation";
    content: string | ParsedCitation;
  }> = [];
  let lastIndex = 0;

  citations.forEach((citation) => {
    const index = text.indexOf(citation.fullCitation, lastIndex);

    // Add text before citation
    if (index > lastIndex) {
      parts.push({
        type: "text",
        content: text.slice(lastIndex, index),
      });
    }

    // Add citation
    parts.push({
      type: "citation",
      content: citation,
    });

    lastIndex = index + citation.fullCitation.length;
  });

  // Add remaining text
  if (lastIndex < text.length) {
    parts.push({
      type: "text",
      content: text.slice(lastIndex),
    });
  }

  return (
    <span className={className}>
      {parts.map((part, index) =>
        part.type === "text" ? (
          <span key={index}>{part.content as string}</span>
        ) : (
          <CitationLink
            key={index}
            citation={part.content as ParsedCitation}
            onClick={onCitationClick}
          />
        )
      )}
    </span>
  );
}



// File Path: src/app/components/Navigation.tsx

import React from 'react';
import Image from 'next/image';
import Link from 'next/link';

const Navigation = () => {
  return (
    <nav className="fixed top-0 left-0 right-0 h-16 flex items-center justify-center border-b border-emerald-900 bg-emerald-950 backdrop-blur-sm z-10">
      <div className="max-w-screen-xl w-full mx-auto px-4 flex justify-center">
        <Link href="/" className="flex items-center">
          {/* Replace with your actual logo or use a placeholder */}
          <div className="relative w-40 h-10">
            <Image 
              src="/logo.svg" 
              alt="Logo"
              fill
              style={{ objectFit: 'contain' }}
              priority
            />
          </div>
        </Link>
      </div>
    </nav>
  );
};

export default Navigation; 


// File Path: src/app/components/PDFViewer.tsx

// src/app/components/PDFViewer.tsx
"use client";

import React, {
  useEffect,
  useRef,
  forwardRef,
  useImperativeHandle,
  useState,
  useCallback,
} from "react";
import * as pdfjs from "pdfjs-dist";

// Set up PDF.js worker
pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.min.js`;

interface PDFViewerProps {
  pdfUrl: string | null;
  initialPage?: number;
  onPageChange?: (page: number) => void;
  fitToWidth?: boolean;
  maxScale?: number;
}

export interface PDFViewerHandle {
  goToPage: (page: number) => void;
}

const PDFViewer = forwardRef<PDFViewerHandle, PDFViewerProps>(
  (
    {
      pdfUrl,
      initialPage = 1,
      onPageChange,
      fitToWidth = true,
      maxScale = 2.0,
    },
    ref
  ) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const canvasContainerRef = useRef<HTMLDivElement>(null);
    const currentPageRef = useRef(initialPage);
    const pdfDocumentRef = useRef<pdfjs.PDFDocumentProxy | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [currentFitMode, setCurrentFitMode] = useState(fitToWidth);

    const calculateScale = useCallback(
      (
        viewport: pdfjs.PageViewport,
        containerWidth: number,
        containerHeight: number
      ): number => {
        if (!currentFitMode) return 1.0;

        // Calculate scale to fit both width and height
        const widthScale = containerWidth / viewport.width;
        const heightScale = containerHeight / viewport.height;

        // Use the smaller scale to ensure the page fits in both dimensions
        const scale = Math.min(widthScale, heightScale);

        // Clamp the scale between 0.1 and maxScale
        return Math.min(Math.max(scale, 0.1), maxScale);
      },
      [currentFitMode, maxScale]
    );

    const renderPage = useCallback(
      async (pageNumber: number) => {
        if (
          !pdfDocumentRef.current ||
          !containerRef.current ||
          !canvasContainerRef.current
        )
          return;

        try {
          setIsLoading(true);
          setError(null);

          const page = await pdfDocumentRef.current.getPage(pageNumber);
          const container = containerRef.current;
          const canvasContainer = canvasContainerRef.current;

          // Get the container dimensions
          const containerWidth = container.clientWidth - 40; // Account for padding
          const containerHeight = container.clientHeight - 40; // Account for padding

          // Get viewport with default scale first
          const viewport = page.getViewport({ scale: 1.0 });

          // Calculate appropriate scale to fit
          const scale = calculateScale(
            viewport,
            containerWidth,
            containerHeight
          );
          const scaledViewport = page.getViewport({ scale });

          // Create canvas
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d")!;
          canvas.height = scaledViewport.height;
          canvas.width = scaledViewport.width;

          // Clear container and append canvas
          canvasContainer.innerHTML = "";
          canvasContainer.appendChild(canvas);

          // Center the canvas in the container
          canvas.style.display = "block";
          canvas.style.margin = "0 auto";

          // Render page
          await page.render({
            canvasContext: context,
            viewport: scaledViewport,
          }).promise;

          // Update current page and notify parent
          currentPageRef.current = pageNumber;
          onPageChange?.(pageNumber);
        } catch (error) {
          console.error("Error rendering page:", error);
          setError(
            `ÿÆÿ∑ÿ£ ŸÅŸä ÿπÿ±ÿ∂ ÿßŸÑÿµŸÅÿ≠ÿ©: ${error instanceof Error ? error.message : String(error)}`
          );
        } finally {
          setIsLoading(false);
        }
      },
      [calculateScale, setIsLoading, setError, onPageChange]
    );

    // Update fit mode when prop changes
    useEffect(() => {
      setCurrentFitMode(fitToWidth);
      if (pdfDocumentRef.current) {
        renderPage(currentPageRef.current);
      }
    }, [fitToWidth, renderPage]);

    // Expose goToPage method via ref
    useImperativeHandle(ref, () => ({
      goToPage: (page: number) => {
        if (pdfDocumentRef.current) {
          renderPage(page);
        }
      },
    }));

    useEffect(() => {
      if (!pdfUrl) return;

      let mounted = true;
      const loadPDF = async () => {
        try {
          setIsLoading(true);
          setError(null);

          const pdf = await pdfjs.getDocument(pdfUrl).promise;

          if (!mounted) {
            pdf.destroy();
            return;
          }

          pdfDocumentRef.current = pdf;
          // Render initial page
          await renderPage(initialPage);
        } catch (error) {
          console.error("Error loading PDF:", error);
          if (mounted) {
            setError(
              `ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÑŸÅ: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        } finally {
          if (mounted) {
            setIsLoading(false);
          }
        }
      };

      loadPDF();

      // Cleanup
      return () => {
        mounted = false;
        if (pdfDocumentRef.current) {
          pdfDocumentRef.current.destroy();
          pdfDocumentRef.current = null;
        }
      };
    }, [pdfUrl, initialPage, renderPage]);

    // Handle window resize
    useEffect(() => {
      const handleResize = () => {
        if (pdfDocumentRef.current) {
          renderPage(currentPageRef.current);
        }
      };

      let timeoutId: NodeJS.Timeout;
      const debouncedResize = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(handleResize, 150);
      };

      window.addEventListener("resize", debouncedResize);
      return () => {
        window.removeEventListener("resize", debouncedResize);
        clearTimeout(timeoutId);
      };
    }, [renderPage]);

    // Handle keyboard navigation
    useEffect(() => {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (!pdfDocumentRef.current) return;

        const totalPages = pdfDocumentRef.current.numPages;

        if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
          e.preventDefault();
          if (currentPageRef.current > 1) {
            renderPage(currentPageRef.current - 1);
          }
        } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
          e.preventDefault();
          if (currentPageRef.current < totalPages) {
            renderPage(currentPageRef.current + 1);
          }
        }
      };

      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, [renderPage]);

    if (error) {
      return (
        <div className="flex items-center justify-center h-full text-red-400 bg-red-900/10 rounded-lg border border-red-500/20 p-4">
          <div className="text-center">
            <p className="text-sm">{error}</p>
            <button
              onClick={() => window.location.reload()}
              className="mt-2 text-xs text-red-400 hover:text-red-300 transition-colors"
            >
              ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©
            </button>
          </div>
        </div>
      );
    }

    return (
      <div
        ref={containerRef}
        className="relative w-full h-[95%] pt-3 overflow-hidden bg-white/10 rounded-lg p-4"
      >
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center bg-emerald-950/80 backdrop-blur-sm rounded-lg z-10">
            <div className="flex items-center gap-3 text-white">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-emerald-400"></div>
              <span>ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÑŸÅ...</span>
            </div>
          </div>
        )}

        <div
          ref={canvasContainerRef}
          className="w-full h-full flex items-center justify-center"
        />

        {pdfUrl && !isLoading && !error && (
          <div className="absolute bottom-2 left-2 bg-black/50 backdrop-blur-sm text-white text-xs px-2 py-1 rounded">
            ÿµŸÅÿ≠ÿ© {currentPageRef.current} ŸÖŸÜ {pdfDocumentRef.current?.numPages}
          </div>
        )}
      </div>
    );
  }
);

PDFViewer.displayName = "PDFViewer";

export default PDFViewer;



// File Path: src/app/components/Sources.tsx

"use client";

import React, { useState, useEffect } from "react";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";
import { Toggle } from "@/components/ui/toggle";
import { FileText, Hash } from "lucide-react";
import { parseCitations, groupCitationsByFile } from "@/utils/citationParser";

interface SourcesProps {
  sessionId: string;
  setPdfUrl: (url: string) => void;
  onPageNavigate?: (pageNumber: number) => void;
}

interface SourceInfo {
  pdfId: Id<"pdfs">;
  filename: string;
  pageRefs: Set<number>;
}

export default function Sources({
  sessionId,
  setPdfUrl,
  onPageNavigate,
}: SourcesProps) {
  // Fetch all ragSources entries for this session
  const sourcesData = useQuery(api.serve.serve.getRagSources, { sessionId });
  // Use the latest entry's pdfIds or empty array
  const pdfIds: Id<"pdfs">[] =
    sourcesData?.[sourcesData.length - 1]?.pdfIds ?? [];

  // Track which PDF is selected
  const [selectedPdfId, setSelectedPdfId] = useState<Id<"pdfs"> | null>(null);
  const [selectedPageNumber, setSelectedPageNumber] = useState<number | null>(
    null
  );
  const [sourceInfos, setSourceInfos] = useState<SourceInfo[]>([]);

  // Query for all PDFs to get their filenames
  const pdfsInfo = useQuery(
    api.pdf.queries.getPdfByIds,
    pdfIds.length > 0 ? { pdfIds } : "skip"
  );

  // Query metadata and file URL when a PDF is selected
  const pdfMeta = useQuery(
    api.pdf.queries.getPdf,
    selectedPdfId ? { pdfId: selectedPdfId } : "skip"
  );
  const fileUrl = useQuery(
    api.files.queries.getFileDownloadUrl,
    pdfMeta?.fileId ? { fileId: pdfMeta.fileId as Id<"_storage"> } : "skip"
  );

  // Query messages to extract citations
  const messages = useQuery(api.serve.serve.retrieveMessages, { sessionId });

  // Get page references for the session by parsing citations from messages
  useEffect(() => {
    if (pdfsInfo && messages) {
      // Parse citations from all bot messages
      const allCitations = messages
        .filter((msg) => !msg.isUser)
        .flatMap((msg) => parseCitations(msg.text));

      // Group citations by file
      const citationSummary = groupCitationsByFile(allCitations);

      // Create source infos with extracted page references
      const infos: SourceInfo[] = pdfsInfo.map((pdf) => {
        const pdfCitations = citationSummary[pdf.filename] || {
          pages: new Set<number>(),
          totalReferences: 0,
        };

        return {
          pdfId: pdf._id,
          filename: pdf.filename,
          pageRefs: pdfCitations.pages,
        };
      });

      setSourceInfos(infos);
    }
  }, [pdfsInfo, messages]);

  // Whenever fileUrl changes, update the parent PDFViewer
  useEffect(() => {
    if (fileUrl) {
      setPdfUrl(fileUrl);
      // Navigate to specific page if selected
      if (selectedPageNumber && onPageNavigate) {
        onPageNavigate(selectedPageNumber);
      }
    }
  }, [fileUrl, setPdfUrl, selectedPageNumber, onPageNavigate]);

  // If there are no sources yet, render nothing
  if (!pdfIds.length) {
    return null;
  }

  // Handler for page number selection
  const handlePageSelect = (pageNumber: number) => {
    setSelectedPageNumber(pageNumber);
    if (onPageNavigate) {
      onPageNavigate(pageNumber);
    }
  };

  // Render toggle buttons for each PDF source with page references
  return (
    <div className="mb-4 animate-in fade-in duration-300">
      <div className="space-y-2">
        {sourceInfos.map((sourceInfo) => (
          <div
            key={sourceInfo.pdfId.toString()}
            className="border-l-2 border-emerald-700/30 pl-2"
          >
            {/* PDF Toggle Button */}
            <Toggle
              pressed={selectedPdfId === sourceInfo.pdfId}
              onPressedChange={() => {
                setSelectedPdfId(sourceInfo.pdfId);
                setSelectedPageNumber(null); // Reset page selection
              }}
              variant="outline"
              className="bg-emerald-950 border-emerald-700/90 text-white/80 h-8 justify-start gap-2
                data-[state=on]:bg-emerald-600/50 data-[state=on]:text-white 
                transition-colors duration-200"
            >
              <FileText className="w-3 h-3" />
              <span className="truncate max-w-[150px]">
                {sourceInfo.filename.replace(/\.[^/.]+$/, "")}
              </span>
            </Toggle>

            {/* Page Reference Buttons */}
            {selectedPdfId === sourceInfo.pdfId &&
              sourceInfo.pageRefs.size > 0 && (
                <div className="flex flex-wrap gap-1 mt-1 ml-6">
                  {Array.from(sourceInfo.pageRefs)
                    .sort((a, b) => a - b)
                    .map((pageNum) => (
                      <button
                        key={pageNum}
                        onClick={() => handlePageSelect(pageNum)}
                        className={`px-2 py-1 text-xs rounded transition-colors ${
                          selectedPageNumber === pageNum
                            ? "bg-emerald-600 text-white"
                            : "bg-emerald-950/50 text-white/70 hover:bg-emerald-700/50"
                        }`}
                      >
                        <div className="flex items-center gap-1">
                          <Hash className="w-2 h-2" />
                          {pageNum}
                        </div>
                      </button>
                    ))}
                </div>
              )}
          </div>
        ))}
      </div>

      {/* Citation Format Example (for testing) */}
      {selectedPdfId && selectedPageNumber && (
        <div className="mt-2 text-xs text-white/50 border-t border-white/10 pt-2">
          Citation: (
          {sourceInfos.find((s) => s.pdfId === selectedPdfId)?.filename}, p.{" "}
          {selectedPageNumber})
        </div>
      )}
    </div>
  );
}



// File Path: src/app/components/TypingIndicator.tsx

import React from 'react';

export default function TypingIndicator() {
  return (
    <div className="flex justify-start">
      <div className="">
        <div className="flex space-x-2 rtl:space-x-reverse">
          <div className="w-2 h-2 rounded-full bg-white/60 animate-bounce" style={{ animationDelay: '0ms' }}></div>
          <div className="w-2 h-2 rounded-full bg-white/60 animate-bounce" style={{ animationDelay: '150ms' }}></div>
          <div className="w-2 h-2 rounded-full bg-white/60 animate-bounce" style={{ animationDelay: '300ms' }}></div>
        </div>
      </div>
    </div>
  );
}


// File Path: src/app/ConvexClientProvider.tsx

"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}


// File Path: src/app/globals.css

/* src/app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow-x: hidden;
}

@layer base {
  * {
    @apply border-border;
    outline-color: var(--ring);
    outline-width: 2px;
    outline-offset: 2px;
  }
  body {
    @apply bg-background text-foreground;
    font-family: 'IBM Plex Sans Arabic', sans-serif;
  }
}

/* Custom Scrollbar Styles */
@layer utilities {
  /* Webkit browsers (Chrome, Safari, Edge) */
  .custom-scrollbar::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    @apply bg-emerald-950/30 backdrop-blur-sm rounded-full;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    @apply bg-emerald-500/60 rounded-full transition-colors duration-200;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    @apply bg-emerald-500/80;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:active {
    @apply bg-emerald-500;
  }

  /* Firefox */
  .custom-scrollbar {
    scrollbar-width: thin;
    scrollbar-color: rgb(16 185 129 / 0.6) rgb(6 78 59 / 0.3);
  }

  /* Thin scrollbar variant */
  .custom-scrollbar-thin::-webkit-scrollbar {
    width: 4px;
    height: 4px;
  }

  .custom-scrollbar-thin::-webkit-scrollbar-track {
    @apply bg-transparent;
  }

  .custom-scrollbar-thin::-webkit-scrollbar-thumb {
    @apply bg-emerald-500/40 rounded-full;
  }

  .custom-scrollbar-thin::-webkit-scrollbar-thumb:hover {
    @apply bg-emerald-500/60;
  }
}

/* Animation for QR code popup */
@keyframes slideInLeft {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutLeft {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(-100%);
    opacity: 0;
  }
}

.animate-slide-in-left {
  animation: slideInLeft 0.5s ease-out forwards;
}

.animate-slide-out-left {
  animation: slideOutLeft 0.5s ease-out forwards;
}


// File Path: src/app/layout.tsx

import type { Metadata } from "next";
import { IBM_Plex_Sans_Arabic, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ConvexClientProvider } from "./ConvexClientProvider";
import Navigation from "./components/Navigation";

const ibmPlexSansArabic = IBM_Plex_Sans_Arabic({
  variable: "--font-ibm-plex-sans-arabic",
  subsets: ["arabic", "latin"],
  weight: ["100", "200", "300", "400", "500", "600", "700"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ•ŸÑŸâ ŸÜÿµŸàÿµ",
  description: "PDF OCR processing application",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ar-en" className="h-full">
      <body
        className={`${ibmPlexSansArabic.variable} ${geistMono.variable} antialiased h-full`}
        style={{ fontFamily: `'IBM Plex Sans Arabic', sans-serif` }}
      >
        <ConvexClientProvider>
          <div className="h-full flex flex-col ">
            <Navigation />
            <main className="flex-1 pt-16 overflow-auto ">{children}</main>
          </div>
        </ConvexClientProvider>
      </body>
    </html>
  );
}



// File Path: src/app/page.tsx

"use client";

import { useState, useEffect } from "react";
import { useMutation } from "convex/react";
import { api } from "../../convex/_generated/api";
import { useRouter } from "next/navigation";
import PDFDropzone from "@/components/PDFDropzone";
import UploadButton from "@/components/UploadButton";
import { MessageCircleMore } from "lucide-react";
import { TextGenerateEffect } from "@/components/ui/text-generate-effect";
import QRCodePopup from "@/components/QRCodePopup";

// Define types for our mutation functions to avoid 'any'
type GenerateUploadUrlFn = () => Promise<string>;
type SendPDFFn = (args: {
  fileId: string;
  filename: string;
  fileSize: number;
  pageCount: number;
}) => Promise<string>;

const words = "ÿßŸÑÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿπÿßŸÖÿ© ŸÑŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿ•ÿµÿ∑ŸÜÿßÿπŸä Ÿàÿ™ÿ∑ŸàŸäÿ± ÿßŸÑÿ£ÿπŸÖÿßŸÑ";
function TextGenerateEffectDemo() {
  return <TextGenerateEffect words={words} />;
}

export default function App() {
  const router = useRouter();
  const generateUploadUrl = useMutation(api.files.mutations.generateUploadUrl);
  const sendPDF = useMutation(api.pdf.mutations.savePdfMetadata);
  // const processWithMultipleOcrMutation = useMutation(api.ocr.actions.processWithMultipleOcrMutation);

  const [selectedPDF, setSelectedPDF] = useState<File | null>(null);
  const [pageCount, setPageCount] = useState<number | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [redirectUrl, setRedirectUrl] = useState<string | null>(null);
  const [showQRPopup, setShowQRPopup] = useState(true);

  // Handle redirection using useEffect
  useEffect(() => {
    if (redirectUrl) {
      router.push(redirectUrl);
    }
  }, [redirectUrl, router]);

  async function handleFormSubmit() {
    if (!selectedPDF) return;

    setIsLoading(true);
    try {
      // Generate upload URL and upload the PDF
      const postUrl = await (
        generateUploadUrl as unknown as GenerateUploadUrlFn
      )();

      // Upload the file to storage
      const result = await fetch(postUrl, {
        method: "POST",
        headers: { "Content-Type": selectedPDF.type },
        body: selectedPDF,
      });
      const { storageId } = await result.json();

      // Save PDF metadata
      const pdfId = await (sendPDF as unknown as SendPDFFn)({
        fileId: storageId,
        filename: selectedPDF.name,
        fileSize: selectedPDF.size,
        pageCount: pageCount || 0,
      });

      // Reset form state
      setSelectedPDF(null);
      setPageCount(null);

      // Start OCR processing in the background
      // await (workflowOrchMutation as unknown as ProcessPDFFn)({ pdfId }).catch(
      //   (error) => console.error("Error processing OCR:", error)
      // );

      // Set redirection URL to trigger navigation
      setRedirectUrl(`/pdf/${pdfId}/pages`);
      setIsLoading(false);
    } catch (error) {
      console.error("Error uploading PDF:", error);
      setIsLoading(false);
    }
  }

  // Handle chat card click to navigate to chat page
  const handleChatCardClick = async () => {
    // If there's a selected PDF, upload it first and then navigate to chat
    router.push("/chat");
  };

  return (
    <div
      className="flex flex-col md:flex-row justify-center items-center gap-6 min-h-screen md:h-full overflow-auto py-20 md:py-0 relative"
      style={{
        backgroundImage: 'url("/background.png")',
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
      }}
    >
      <section className="w-[300px] bg-white/10 backdrop-blur-md shadow-lg rounded-2xl p-6 border border-white/20 h-[400px] text-white hover:bg-white/20 transition-colors cursor-pointer">
        <h2 className="text-3xl font-semibold mb-4 text-right">
          ÿßÿ±ŸÅÿπ ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ŸÉ
        </h2>
        <form className="space-y-4" onSubmit={(e) => e.preventDefault()}>
          <PDFDropzone
            selectedPDF={selectedPDF}
            setSelectedPDF={setSelectedPDF}
            pageCount={pageCount}
            setPageCount={setPageCount}
            isLoading={isLoading}
            setIsLoading={setIsLoading}
          />

          <UploadButton
            selectedPDF={selectedPDF}
            isLoading={isLoading}
            onSubmit={handleFormSubmit}
          />
        </form>
      </section>

      {/* Gold AI card */}
      <section
        className="w-[300px] h-[400px] shadow-lg rounded-2xl p-6 border border-amber-400 h-100 flex flex-col items-center justify-center"
        style={{
          background: "linear-gradient(145deg, #d4af37 10%, #b8860b 40%)",
          boxShadow: "0 10px 25px -5px rgba(180, 130, 20, 0.5)",
        }}
      >
        <TextGenerateEffectDemo />

        <p className="text-white font-medium text-center">
          ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ•ŸÑŸâ ŸÜÿµŸàÿµ ÿπŸÜ ÿ∑ÿ±ŸäŸÇ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿ•ÿµÿ∑ŸÜÿßÿπŸä
        </p>
      </section>

      {/* Chat card with onClick handler */}
      <section
        className="w-[300px] h-[400px] flex flex-col bg-white/10 backdrop-blur-md shadow-lg rounded-2xl p-6 border border-white/20 text-white hover:bg-white/20 transition-colors cursor-pointer"
        onClick={handleChatCardClick}
      >
        <div>
          <h2 className="text-3xl font-semibold mb-4 text-right">
            ÿ™ÿ≠ÿØÿ´ ŸÖÿπ ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ŸÉ
          </h2>
          <p className="text-white/80 text-right">
            ÿ™ÿ≠ÿØÿ´ ŸÖÿπ ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ŸÉ ÿ®ÿ£ÿ≥ŸáŸÑ ÿ∑ÿ±ŸäŸÇÿ©
          </p>
        </div>
        {/* Chat icon from Lucide */}
        <div className="flex-1 flex justify-center items-center w-full">
          <MessageCircleMore className="w-40 h-40 text-white/80" />
        </div>
      </section>

      {/* QR Code Popup Component */}
      {showQRPopup && <QRCodePopup onClose={() => setShowQRPopup(false)} />}
    </div>
  );
}



// File Path: src/app/pdf/hooks/usePageQuery.tsx

import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import type { PdfPageInfo } from "../types";
import type { Id } from "../../../../convex/_generated/dataModel";

export function usePagesQuery(pdfId: Id<"pdfs"> | undefined) {
  return useQuery(
    api.pdf.queries.getPagesByPdf,
    pdfId ? { pdfId } : "skip"
  ) as PdfPageInfo[] | undefined;
}


// File Path: src/app/pdf/pages/context.tsx

// src/app/pdf/pages/context.tsx (update)
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";

interface PdfPageContextValue {
  page: number;
  setPage: (page: number) => void;
  totalPages: number;
}

const PdfPageContext = createContext<PdfPageContextValue | undefined>(
  undefined
);

interface PdfPageProviderProps {
  children: ReactNode;
  initialPage?: number;
  totalPages?: number;
}

export const PdfPageProvider = ({
  children,
  initialPage = 1,
  totalPages = 0,
}: PdfPageProviderProps) => {
  const [page, setPage] = useState<number>(initialPage);

  const value = {
    page,
    setPage,
    totalPages,
  };

  return (
    <PdfPageContext.Provider value={value}>{children}</PdfPageContext.Provider>
  );
};

export const usePdfPage = () => {
  const context = useContext(PdfPageContext);
  if (context === undefined) {
    throw new Error("usePdfPage must be used within a PdfPageProvider");
  }
  return context;
};



// File Path: src/app/pdf/pages/StreamCleanPage.ts

// src/app/pdf/pages/streamCleanPage.ts (update with debounce)
import { Id } from "../../../../convex/_generated/dataModel";
import debounce from 'lodash.debounce';

export async function streamCleanPage(
  pageId: Id<"pages">, 
  src: "gemini" | "replicate", 
  onChunk: (c: string) => void,
  onError?: (error: Error) => void
): Promise<void> {
  console.log(`Starting stream cleaning for ${src} OCR of page ${pageId}`);
  
  try {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_CONVEX_URL_HTTP}/cleanPage`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Origin": window.location.origin
      },
      body: JSON.stringify({ pageId, source: src }),
    });

    if (!resp.ok) {
      const errorText = await resp.text();
      console.error(`Error from cleanPage endpoint (${resp.status}):`, errorText);
      throw new Error(`Server error: ${resp.status} - ${errorText}`);
    }

    if (!resp.body) {
      throw new Error('Response body is null');
    }

    const reader = resp.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let fullText = "";
    
    // Create debounced update function
    const debouncedUpdate = debounce(onChunk, 300);
    
    // Start with an empty update to indicate streaming has begun
    onChunk("");
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const newChunk = decoder.decode(value, { stream: true });
      fullText += newChunk;
      
      // Use debounced update for smoother UI
      debouncedUpdate(fullText);
    }
    
    // Ensure final text is processed with any remaining decoder content
    const finalChunk = decoder.decode();
    if (finalChunk) {
      fullText += finalChunk;
    }
    
    // Flush pending debounced calls and do final update
    debouncedUpdate.flush();
    onChunk(fullText);
    
    console.log(`Completed stream cleaning for ${src} OCR of page ${pageId}`);
  } catch (error) {
    console.error(`Stream clean error for ${src} OCR of page ${pageId}:`, error);
    if (onError && error instanceof Error) {
      onError(error);
    } else if (error instanceof Error) {
      throw error;
    } else {
      throw new Error(String(error));
    }
  }
}


// File Path: src/app/pdf/StreamedTextBox.tsx

// src/app/pdf/StreamedTextBox.tsx
"use client";

import { Id } from "../../../convex/_generated/dataModel";
import { usePageStream, selectChunk } from "@/store/pageStreams";
import TypingIndicator from "@/app/components/TypingIndicator";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { motion } from "motion/react";
import { CheckCircle, AlertCircle, Loader2 } from "lucide-react";

interface StreamedTextBoxProps {
  pageId: Id<"pages">;
  src: "gemini" | "replicate";
}

export default function StreamedTextBox({ pageId, src }: StreamedTextBoxProps) {
  // Get streaming text from store
  const chunks = usePageStream((state) => selectChunk(pageId, src)(state));

  // Get cleaning status for this page
  const pageResults = useQuery(
    src === "gemini"
      ? api.ocr.gemini.queries.getPageOcrResults
      : api.ocr.replicate.queries.getPageOcrResults,
    { pageId }
  );

  const cleaningResults = useQuery(
    api.ocr.openai.queries.getPageCleanedResults,
    {
      pageId,
      source: src,
    }
  );

  const isCompleted = cleaningResults?.cleaningStatus === "completed";
  const hasText = chunks && chunks.length > 0;
  const ocrStatus = pageResults?.ocrResults?.ocrStatus;

  // Determine status icon and message
  let statusIcon;
  let statusMessage;

  if (isCompleted) {
    statusIcon = <CheckCircle className="w-4 h-4 text-emerald-400" />;
    statusMessage = "ÿßŸÉÿ™ŸÖŸÑÿ™ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©";
  } else if (ocrStatus === "failed") {
    statusIcon = <AlertCircle className="w-4 h-4 text-red-400" />;
    statusMessage = "ŸÅÿ¥ŸÑÿ™ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©";
  } else if (ocrStatus === "completed" && !hasText) {
    statusIcon = <Loader2 className="w-4 h-4 text-blue-400 animate-spin" />;
    statusMessage = "ÿ¨ÿßÿ±Ÿä ÿ™ŸÜŸÇŸäÿ≠ ÿßŸÑŸÜÿµ...";
  } else if (ocrStatus === "processing") {
    statusIcon = <Loader2 className="w-4 h-4 text-emerald-400 animate-spin" />;
    statusMessage = "ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµ...";
  } else {
    statusIcon = <div className="w-4 h-4 rounded-full bg-gray-400/30" />;
    statusMessage = "ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...";
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 5 }}
      animate={{ opacity: 1, y: 0 }}
      className="relative space-y-2"
    >
      {/* Status Header */}
      <div className="flex items-center gap-2 text-xs text-white/70">
        {statusIcon}
        <span>{statusMessage}</span>
      </div>

      {/* Text Content */}
      {!hasText && !isCompleted ? (
        <div className="min-h-[100px] flex items-center justify-center bg-white/5 backdrop-blur-sm rounded-lg border border-white/10 p-4">
          <TypingIndicator />
        </div>
      ) : (
        <motion.div
          initial={{ height: 0 }}
          animate={{ height: "auto" }}
          transition={{ duration: 0.3 }}
          className="overflow-hidden"
        >
          <pre className="min-h-[100px] max-h-[250px] overflow-y-auto text-white/90 bg-white/5 backdrop-blur-sm rounded-lg border border-white/10 p-4 text-right font-sans text-xl whitespace-pre-wrap leading-relaxed">
            {chunks || "ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©..."}
          </pre>
        </motion.div>
      )}
    </motion.div>
  );
}



// File Path: src/app/pdf/types.ts

import { Id } from "../../../convex/_generated/dataModel";

// OCR status values used across the application
export type OcrStatus = "pending" | "processing" | "completed" | "failed";

// Type for page information used in the pages accordion
export type PdfPageInfo = {
  pageId: Id<"pages">;
  pageNumber: number;
  geminiStatus: OcrStatus;
  replicateStatus: OcrStatus;
  cleanedSnippet: string | null;
};


// File Path: src/app/pdf/[storageId]/components/ErrorAlert.tsx

// src/app/pdf/[storageId]/components/ErrorAlert.tsx
import React from 'react';

interface ErrorAlertProps {
  message: string;
}

export default function ErrorAlert({ message }: ErrorAlertProps) {
  return (
    <div className="fixed top-4 right-4 bg-red-600/90 backdrop-blur-md text-white px-4 py-2 rounded-lg shadow-lg z-50 max-w-md">
      <div className="flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <span>{message}</span>
      </div>
    </div>
  );
}


// File Path: src/app/pdf/[storageId]/components/GeminiOCRSection.tsx

import React from 'react'
import MDXEditorWrapper from './MDXEditorWrapper'
import { formatTimestamp } from '../utils/formatUtils'

interface GeminiOCRProps {
  geminiResults: {
    ocrResults?: {
      processedAt?: number;
      confidenceScore?: number;
      extractedText?: string;
    }
  } | null | undefined;
  editedGeminiText: string;
  handleGeminiTextChange: (text: string) => void;
}

const GeminiOCRSection = ({ 
  geminiResults, 
  editedGeminiText, 
  handleGeminiTextChange 
}: GeminiOCRProps) => {
  return (
    <div className="bg-blue-100 p-4 rounded-lg mb-2">
      {/* <h3 className="text-xl font-medium text-blue-800 mb-2">Gemini OCR</h3> */}
      {geminiResults?.ocrResults ? (
        <div>
          <div className="text-sm text-gray-600 mb-2">
            Processed: {formatTimestamp(geminiResults.ocrResults.processedAt)}
          </div>
          <MDXEditorWrapper 
            markdown={editedGeminiText} 
            onChange={handleGeminiTextChange} 
          />
        </div>
      ) : (
        <div className="text-black italic">Ÿäÿ™ŸÖ ÿßŸÑÿ¢ŸÜ ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµŸàÿµ</div>
      )}
    </div>
  )
}

export default GeminiOCRSection 


// File Path: src/app/pdf/[storageId]/components/GlassmorphicProgressStepper.tsx

// src/app/pdf/[storageId]/components/GlassmorphicProgressStepper.tsx
import React from 'react';
import { CheckCircle, Loader2 } from 'lucide-react';

export type OcrStep = 'uploaded' | 'processing' | 'streaming' | 'completed';

interface GlassmorphicProgressStepperProps {
  currentStep: OcrStep;
  modelType: 'gemini' | 'replicate';
}

export default function GlassmorphicProgressStepper({ 
  currentStep,
  modelType
}: GlassmorphicProgressStepperProps) {
  // Define the ordered steps for display - first is rightmost in RTL
  const orderedSteps: { key: OcrStep; label: string }[] = [
    { key: 'uploaded', label: 'ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÑŸÅ' },
    { key: 'processing', label: 'ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµ' },
    { key: 'streaming', label: 'ÿ™ŸÜŸÇŸäÿ≠ ÿßŸÑŸÜÿµ' },
    { key: 'completed', label: 'ÿßŸÉÿ™ŸÖŸÑ' }
  ];

  // Map the current step value to its index in our ordered steps
  const currentStepIndex = orderedSteps.findIndex(step => step.key === currentStep);
  
  // Process each step to determine its status
  const processedSteps = orderedSteps.map((step, index) => {
    // A step is completed if:
    // 1. We have moved past this step (index < currentStepIndex)
    // 2. Or it's the last step (index === orderedSteps.length - 1) and current step is 'completed'
    const isLastStep = index === orderedSteps.length - 1;
    const isCompleted = 
      index < currentStepIndex || 
      (isLastStep && currentStep === 'completed');
    
    const status = isCompleted ? 'completed' : 'loading';
    
    // Assign the appropriate icon based on status
    const icon = 
      status === 'completed' ? <CheckCircle className="w-5 h-5 text-emerald-400" /> :
      <Loader2 className="w-5 h-5 text-white/40 animate-spin" />;
    
    return {
      ...step,
      status,
      icon
    };
  });

  return (
    <div className="mb-2 rounded-lg bg-emerald-950/60 backdrop-blur-md border border-emerald-800/30 shadow-lg p-2" dir="rtl">
      {/* Render modelType label */}
      <div className="px-2 text-xs font-medium text-white mb-1">{modelType}</div>
      <div className="flex items-center justify-between px-1">
        {processedSteps.map((step, index) => (
          <React.Fragment key={step.key}>
            {/* Step with icon and label */}
            <div className="flex flex-col items-center">
              <div className={`flex items-center justify-center rounded-full w-7 h-7 
                ${step.status === 'completed' ? 'bg-emerald-600/20' : 'bg-white/10'}`}
              >
                {step.icon}
              </div>
              <span className={`text-xs mt-1 text-center
                ${step.status === 'completed' ? 'text-emerald-400' : 'text-white/40'}`}
              >
                {step.label}
              </span>
            </div>
            
            {/* Connector line between steps */}
            {index < processedSteps.length - 1 && (
              <div className="h-[1px] flex-1 mx-2 bg-gradient-to-l from-emerald-500/30 to-emerald-400/20" />
            )}
          </React.Fragment>
        ))}
      </div>
    </div>
  );
}


// File Path: src/app/pdf/[storageId]/components/MDXEditorWrapper.tsx

import dynamic from 'next/dynamic'

// Dynamically import MDXEditor to avoid SSR issues
const MDXEditorComponent = dynamic(
  () => import('@mdxeditor/editor').then((mod) => {
    const { MDXEditor } = mod
    return function MDXEditorWrapper({ markdown, onChange }: { markdown: string, onChange: (markdown: string) => void }) {
      return (
        <MDXEditor 
          markdown={markdown}
          onChange={onChange}
          contentEditableClassName="prose max-w-full text-black bg-white/90 p-3 rounded-lg border border-emerald-800/20 min-h-[200px] max-h-[300px] overflow-y-auto shadow-inner"
        />
      )
    }
  }),
  { ssr: false }
)

interface MDXEditorWrapperProps {
  markdown: string;
  onChange: (markdown: string) => void;
}

// This wrapper component is needed to handle the dynamic import
const MDXEditorWrapper = ({ markdown, onChange }: MDXEditorWrapperProps) => {
  return <MDXEditorComponent markdown={markdown} onChange={onChange} />
}

export default MDXEditorWrapper 


// File Path: src/app/pdf/[storageId]/components/MinimalistProgressBar.tsx

// src/app/pdf/[storageId]/components/MinimalistProgressBar.tsx
import React from "react";
import { OcrStep } from "./OcrProgressStepper";

interface MinimalistProgressBarProps {
  currentStep: OcrStep;
  modelType: "gemini" | "replicate";
}

export default function MinimalistProgressBar({
  currentStep,
  modelType,
}: MinimalistProgressBarProps) {
  // Define steps and their order
  const stepOrder: OcrStep[] = [
    "uploaded",
    "processing",
    "streaming",
    "completed",
  ];

  // Calculate progress percentage based on current step
  const currentIndex = stepOrder.indexOf(currentStep);
  const totalSteps = stepOrder.length;
  const progressPercentage = ((currentIndex + 1) / totalSteps) * 100;

  // Define model-specific styles
  const colorClasses = {
    gemini: "bg-blue-500",
    replicate: "bg-purple-500",
  };

  return (
    <div className="absolute top-0 left-0 right-0 h-1.5 rounded-t-lg">
      <div className="w-full h-full bg-white/10"></div>
      <div
        className={`absolute top-0 left-0 h-full transition-all duration-700 ease-in-out ${colorClasses[modelType]}`}
        style={{ width: `${progressPercentage}%` }}
      ></div>
    </div>
  );
}



// File Path: src/app/pdf/[storageId]/components/OcrProgressStepper.tsx

// src/app/pdf/[storageId]/components/OcrProgressStepper.tsx
import React from "react";
import { CheckCircle, Clock, Loader2 } from "lucide-react";

export type OcrStep = "uploaded" | "processing" | "streaming" | "completed";

interface OcrStepInfo {
  key: OcrStep;
  label: string;
  icon: React.ReactNode;
  status: "completed" | "current" | "pending";
}

interface OcrProgressStepperProps {
  currentStep: OcrStep;
  modelType: "gemini" | "replicate";
}

export default function OcrProgressStepper({
  currentStep,
  modelType,
}: OcrProgressStepperProps) {
  // Define steps for the OCR process
  const steps: Record<OcrStep, string> = {
    uploaded: "ÿ™ŸÖ ÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅ",
    processing: "ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµ",
    streaming: "ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑŸÜÿµ",
    completed: "ÿßŸÉÿ™ŸÖŸÑ",
  };

  // Create the step information array with status
  const stepInfo: OcrStepInfo[] = Object.entries(steps).map(([key, label]) => {
    let status: "completed" | "current" | "pending";

    if (key === currentStep) {
      status = "current";
    } else if (
      (key === "uploaded" &&
        ["processing", "streaming", "completed"].includes(currentStep)) ||
      (key === "processing" &&
        ["streaming", "completed"].includes(currentStep)) ||
      (key === "streaming" && currentStep === "completed")
    ) {
      status = "completed";
    } else {
      status = "pending";
    }

    return {
      key: key as OcrStep,
      label,
      status,
      icon:
        status === "completed" ? (
          <CheckCircle className="w-6 h-6 text-green-500" />
        ) : status === "current" ? (
          <Loader2 className="w-6 h-6 text-white animate-spin" />
        ) : (
          <Clock className="w-6 h-6 text-white/40" />
        ),
    };
  });

  // Colors for model type
  const colorClasses = {
    gemini: "from-blue-600 to-blue-800", // Blue for Gemini
    replicate: "from-purple-600 to-purple-800", // Purple for Replicate
  };

  return (
    <div className="mb-4">
      <div
        className={`rounded-lg border border-white/20 p-3 bg-gradient-to-r ${colorClasses[modelType]} backdrop-blur-md shadow-lg`}
      >
        <h3 className="text-base font-medium mb-3 text-white text-right">
          {modelType === "gemini"
            ? "ŸÜŸÖŸàÿ∞ÿ¨ ŸÖÿ∫ŸÑŸÇ ÿßŸÑŸÖÿµÿØÿ± (ÿ¨ŸäŸÖŸäŸÜŸä)"
            : "ŸÜŸÖŸàÿ∞ÿ¨ ŸÖŸÅÿ™Ÿàÿ≠ ÿßŸÑŸÖÿµÿØÿ± (ÿ±Ÿäÿ®ŸÑŸäŸÉÿ™)"}
        </h3>

        <div className="flex items-center justify-between">
          {stepInfo.map((step, index) => (
            <React.Fragment key={step.key}>
              {/* Step circle with icon */}
              <div className="flex flex-col items-center">
                <div
                  className={`rounded-full w-10 h-10 flex items-center justify-center border-2 ${
                    step.status === "completed"
                      ? "border-green-500 bg-green-500/20"
                      : step.status === "current"
                        ? "border-white bg-white/20"
                        : "border-white/40 bg-white/10"
                  }`}
                >
                  {step.icon}
                </div>
                <span
                  className={`text-xs mt-1 whitespace-nowrap ${
                    step.status === "completed"
                      ? "text-green-300"
                      : step.status === "current"
                        ? "text-white"
                        : "text-white/40"
                  }`}
                >
                  {step.label}
                </span>
              </div>

              {/* Connector line between steps */}
              {index < stepInfo.length - 1 && (
                <div
                  className={`h-0.5 flex-1 mx-1 ${
                    stepInfo[index + 1].status === "completed" ||
                    (stepInfo[index].status === "completed" &&
                      stepInfo[index + 1].status === "current")
                      ? "bg-green-500"
                      : "bg-white/30"
                  }`}
                />
              )}
            </React.Fragment>
          ))}
        </div>
      </div>
    </div>
  );
}



// File Path: src/app/pdf/[storageId]/components/OpenAICleanedSection.tsx




// File Path: src/app/pdf/[storageId]/components/pdfPreviewSection.tsx

import React from 'react'

export default function PdfPreviewSection({pdfUrl}: {pdfUrl: string | null}) {
  return (
    <div className="w-full h-full">
    {pdfUrl ? (
        <div className="bg-white/10 backdrop-blur-md shadow-lg rounded-2xl p-2 border border-white/20">
            <iframe
                src={pdfUrl}
                title="PDF Viewer"
                width="100%"
                height="500px"
                className="max-h-[900px] h-[50vh] md:h-[900px]"
                style={{ border: 'none', borderRadius: '12px' }}
            />
        </div>
    ) : (
        <div className="w-full h-[50vh] md:h-[900px] max-h-[900px] flex items-center justify-center bg-white/10 backdrop-blur-md rounded-2xl border border-white/20 text-white">
            Loading PDF...
        </div>
    )}
</div>
    
  )
}




// File Path: src/app/pdf/[storageId]/components/ReplicateOCRSection.tsx

import React from 'react'
import MDXEditorWrapper from './MDXEditorWrapper'
import { formatTimestamp } from '../utils/formatUtils'

interface ReplicateOCRProps {
  replicateResults: {
    ocrResults?: {
      processedAt?: number;
      replicateModelId?: string;
      extractedText?: string;
    }
  } | null | undefined;
  editedReplicateText: string;
  handleReplicateTextChange: (text: string) => void;
}

const ReplicateOCRSection = ({ 
  replicateResults, 
  editedReplicateText, 
  handleReplicateTextChange 
}: ReplicateOCRProps) => {
  return (
    <div className="bg-purple-100 p-4 rounded-lg mb-2">
      <h3 className="text-xl font-medium text-purple-800 mb-2">Replicate OCR</h3>
      {replicateResults?.ocrResults ? (
        <div>
          <div className="text-sm text-gray-600 mb-2">
            Processed: {formatTimestamp(replicateResults.ocrResults.processedAt)}
            <span className="ml-2">| Model: {replicateResults.ocrResults.replicateModelId}</span>
          </div>
          <MDXEditorWrapper 
            markdown={editedReplicateText} 
            onChange={handleReplicateTextChange} 
          />
        </div>
      ) : (
        <div className="text-gray-500 italic">Ÿäÿ™ŸÖ ÿßŸÑÿ¢ŸÜ ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµŸàÿµ</div>
      )}
    </div>
  )
}

export default ReplicateOCRSection 


// File Path: src/app/pdf/[storageId]/components/SkeletonLoader.tsx

import React from 'react';

export default function SkeletonLoader() {
  return (
    <div 
      className='flex flex-row items-start justify-center min-h-screen p-4 animate-pulse'
      style={{
        backgroundImage: 'url("/background.png")',
        backgroundSize: 'contain',
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat'
      }}
    >
      {/* PDF Viewer Skeleton */}
      <div className="w-1/2 pr-2">
        <div className="w-full h-[900px] bg-white/10 backdrop-blur-sm border border-white/20 rounded-2xl"></div>
      </div>
      
      {/* OCR Results Skeleton */}
      <div className="w-1/2 pl-4 pr-2">
        <div className="h-8 w-64 bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl mb-6"></div>
        
        {/* Gemini Results Skeleton */}
        <div className="mb-8">
          <div className="h-6 w-48 bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl mb-3"></div>
          <div className="h-32 w-full bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl mb-3"></div>
          <div className="flex space-x-2 mb-6">
            <div className="h-8 w-20 bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl"></div>
            <div className="h-8 w-20 bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl"></div>
          </div>
        </div>
        
        {/* Replicate Results Skeleton */}
        <div className="mb-8">
          <div className="h-6 w-48 bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl mb-3"></div>
          <div className="h-32 w-full bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl mb-3"></div>
          <div className="flex space-x-2 mb-6">
            <div className="h-8 w-20 bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl"></div>
            <div className="h-8 w-20 bg-white/10 backdrop-blur-sm border border-white/20 rounded-xl"></div>
          </div>
        </div>
      </div>
    </div>
  );
} 


// File Path: src/app/pdf/[storageId]/hooks/useKickClean.tsx

// src/app/pdf/hooks/useKickClean.tsx
"use client";

import { useEffect } from "react";
import { useQuery } from "convex/react";
import { api } from "../../../../../convex/_generated/api";
import { Id } from "../../../../../convex/_generated/dataModel";
import { streamCleanPage } from "@/app/pdf/pages/StreamCleanPage";
import { usePageStream } from "@/store/pageStreams";

interface UseKickCleanProps {
  pageId: Id<"pages">;
  src: "gemini" | "replicate";
}

export function useKickClean({ pageId, src }: UseKickCleanProps) {
  const { setChunk, chunks, inFlight, markInFlight, clearInFlight } =
    usePageStream();

  // Monitor OCR status based on source
  const ocrResults = useQuery(
    src === "gemini"
      ? api.ocr.gemini.queries.getPageOcrResults
      : api.ocr.replicate.queries.getPageOcrResults,
    { pageId }
  );

  useEffect(() => {
    const key = `${pageId}_${src}` as const;
    const ocrCompleted = ocrResults?.ocrResults?.ocrStatus === "completed";
    const hasChunk = chunks[key]?.length > 0;

    if (ocrCompleted && !hasChunk && !inFlight.has(key)) {
      markInFlight(key);
      console.log(`Triggering ${src} clean for page ${pageId}`);

      streamCleanPage(pageId, src, (chunk) => {
        setChunk(key, chunk);
      })
        .catch((error) => {
          console.error(`Error streaming ${src} cleanup:`, error);
        })
        .finally(() => {
          clearInFlight(key);
        });
    }
  }, [
    pageId,
    src,
    ocrResults?.ocrResults?.ocrStatus,
    chunks,
    inFlight,
    markInFlight,
    clearInFlight,
    setChunk,
  ]);
}



// File Path: src/app/pdf/[storageId]/hooks/useOcrProcessing.tsx

// First, let's create a custom hook for OCR processing

// src/app/pdf/[storageId]/hooks/useOcrProcessing.ts
import { useState, useEffect } from 'react';
import { useQuery } from 'convex/react';
import { api } from '../../../../../convex/_generated/api';
import { Id } from '../../../../../convex/_generated/dataModel';
import { streamClean } from '../streamClean';

export interface OcrState {
  geminiText: string;
  replicateText: string;
  isGeminiProcessing: boolean;
  isReplicateProcessing: boolean;
  error: string | null;
}

export function useOcrProcessing(pdfId: Id<'pdfs'>) {
  const [state, setState] = useState<OcrState>({
    geminiText: '',
    replicateText: '',
    isGeminiProcessing: false,
    isReplicateProcessing: false,
    error: null
  });

  // Fetch OCR results for Gemini and Replicate
  const geminiJobStatus = useQuery(api.ocr.gemini.queries.getOcrByPdfId, { pdfId });
  const replicateJobStatus = useQuery(api.ocr.replicate.queries.getOcrByPdfId, { pdfId });
  
  // Fetch cleaned results if they exist
  const openaiGeminiResults = useQuery(api.ocr.openai.queries.getCleanedId, { 
    pdfId, 
    source: 'gemini' 
  });
  const openaiReplicateResults = useQuery(api.ocr.openai.queries.getCleanedId, { 
    pdfId, 
    source: 'replicate' 
  });

  // Process Gemini results
  useEffect(() => {
    // Only run once when status changes to completed and text is empty
    if (geminiJobStatus?.[0]?.ocrStatus === 'completed' && !state.geminiText && !state.isGeminiProcessing) {
      setState(prev => ({ ...prev, isGeminiProcessing: true }));
      
      // Check if cleaned results already exist
      if (openaiGeminiResults?.[0]?.cleaningStatus === 'completed') {
        setState(prev => ({ 
          ...prev, 
          geminiText: openaiGeminiResults[0].cleanedText,
          isGeminiProcessing: false 
        }));
      } else {
        // Stream clean the results
        streamClean(
          pdfId as string, 
          'gemini', 
          chunk => setState(prev => ({ ...prev, geminiText: chunk }))
        )
        .catch(error => {
          console.error('Error streaming Gemini cleanup:', error);
          setState(prev => ({ 
            ...prev, 
            error: `Failed to process Gemini OCR: ${error.message}`,
            isGeminiProcessing: false 
          }));
        })
        .finally(() => {
          setState(prev => ({ ...prev, isGeminiProcessing: false }));
        });
      }
    }
  }, [geminiJobStatus, openaiGeminiResults, pdfId, state.geminiText, state.isGeminiProcessing]);

  // Process Replicate results (same pattern)
  useEffect(() => {
    if (replicateJobStatus?.[0]?.ocrStatus === 'completed' && !state.replicateText && !state.isReplicateProcessing) {
      setState(prev => ({ ...prev, isReplicateProcessing: true }));
      
      if (openaiReplicateResults?.[0]?.cleaningStatus === 'completed') {
        setState(prev => ({ 
          ...prev, 
          replicateText: openaiReplicateResults[0].cleanedText,
          isReplicateProcessing: false 
        }));
      } else {
        streamClean(
          pdfId as string, 
          'replicate', 
          chunk => setState(prev => ({ ...prev, replicateText: chunk }))
        )
        .catch(error => {
          console.error('Error streaming Replicate cleanup:', error);
          setState(prev => ({ 
            ...prev, 
            error: `Failed to process Replicate OCR: ${error.message}`,
            isReplicateProcessing: false 
          }));
        })
        .finally(() => {
          setState(prev => ({ ...prev, isReplicateProcessing: false }));
        });
      }
    }
  }, [replicateJobStatus, openaiReplicateResults, pdfId, state.replicateText, state.isReplicateProcessing]);

  return {
    geminiText: state.geminiText || 'Ÿäÿ™ŸÖ ÿßŸÑÿ¢ŸÜ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖŸÑŸÅ Ÿàÿ™ÿ≠ŸàŸäŸÑŸá ÿ•ŸÑŸâ ŸÜÿµ',
    replicateText: state.replicateText || 'Ÿäÿ™ŸÖ ÿßŸÑÿ¢ŸÜ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖŸÑŸÅ Ÿàÿ™ÿ≠ŸàŸäŸÑŸá ÿ•ŸÑŸâ ŸÜÿµ',
    isGeminiProcessing: state.isGeminiProcessing,
    isReplicateProcessing: state.isReplicateProcessing,
    error: state.error
  };
}


// File Path: src/app/pdf/[storageId]/OCRfile.tsx

import React from 'react'

interface OCRfileProps {
  textToDisplay: string;
  closed: boolean;
  hide?: boolean;
}

export default function OCRfile({ 
  textToDisplay, 
  closed, 
  hide = false
}: OCRfileProps) {
  const modelLabel = closed ? 
    'ŸÜŸÖŸàÿ∞ÿ¨ ŸÖÿ∫ŸÑŸÇ ÿßŸÑŸÖÿµÿØÿ± (ŸÑÿß ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿ∂ÿßŸÅÿ™Ÿá ÿØÿßÿÆŸÑ ÿßŸÑŸàÿ≤ÿßÿ±ÿ©)' : 
    'ŸÜŸÖŸàÿ∞ÿ¨ ŸÖŸÅÿ™Ÿàÿ≠ ÿßŸÑŸÖÿµÿØÿ± (ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿ∂ÿßŸÅÿ™Ÿá ÿØÿßÿÆŸÑ ÿßŸÑŸàÿ≤ÿßÿ±ÿ©)';
    
  return (
    <div className="bg-emerald-950/70 backdrop-blur-md p-3 md:p-4 rounded-lg border border-white/20 shadow-lg">
      <div className="flex flex-col w-full overflow-y-auto">
        <h3 className="text-base md:text-lg font-medium mb-2 text-white text-right">
          {modelLabel}
        </h3>
        
        <div className="relative">
          {/* Only show content if not hidden */}
          {!hide ? (
            <div 
              className="prose max-w-full text-black bg-white/90 p-3 rounded-lg border border-emerald-800/20 min-h-[150px] md:min-h-[200px] max-h-[200px] md:max-h-[300px] overflow-y-auto shadow-inner relative animate-in fade-in duration-500"
              dir="rtl"
            >
            
              <pre className="whitespace-pre-wrap text-right font-sans text-sm md:text-base">{textToDisplay}</pre>
            </div>
          ) : (
            <div 
              className="prose max-w-full bg-white/5 backdrop-blur-md p-3 rounded-lg border border-emerald-800/10 min-h-[50px] md:min-h-[80px] shadow-inner relative flex items-center justify-center"
            >
            </div>
          )}
        </div>
      </div>
    </div>
  )
}


// File Path: src/app/pdf/[storageId]/page.tsx

"use client";

import React, { useState, useEffect } from "react";
import { useParams } from "next/navigation";
import { useQuery } from "convex/react";
import { Id } from "../../../../convex/_generated/dataModel";
import { api } from "../../../../convex/_generated/api";
import { streamClean } from "./streamClean";
import OCRfile from "./OCRfile";
import PdfPreviewSection from "./components/pdfPreviewSection";
import GlassmorphicProgressStepper, {
  OcrStep,
} from "./components/GlassmorphicProgressStepper";

export default function PdfView() {
  // Extract the dynamic segment directly
  const params = useParams<{ storageId?: string }>();
  const storageId = params.storageId;
  if (!storageId) {
    throw new Error("Missing storageId parameter");
  }
  const jobId = storageId as Id<"pdfs">;
  // redirect(`/pdf/${jobId}/pages`);

  // Data-loading hooks
  const job = useQuery(api.ocr.gemini.queries.getOcrByPdfId, { pdfId: jobId });
  const jobReplicate = useQuery(api.ocr.replicate.queries.getOcrByPdfId, {
    pdfId: jobId,
  });
  const openaiGeminiResults = useQuery(api.ocr.openai.queries.getCleanedId, {
    pdfId: jobId,
    source: "gemini",
  });
  const openaiReplicateResults = useQuery(api.ocr.openai.queries.getCleanedId, {
    pdfId: jobId,
    source: "replicate",
  });

  const [pdfUrl, setPdfUrl] = useState<string>("");

  // Initialize state after data is loaded
  const [initialized, setInitialized] = useState(false);

  // Track processing state and results
  const [gBuf, setG] = useState("");
  const [rBuf, setR] = useState("");
  const [isLoadingGemini, setIsLoadingGemini] = useState(false);
  const [isLoadingReplicate, setIsLoadingReplicate] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Track progress steps - don't set initial value yet
  const [geminiStep, setGeminiStep] = useState<OcrStep>("uploaded");
  const [replicateStep, setReplicateStep] = useState<OcrStep>("uploaded");

  // Query the PDF data using the storageId
  const pdfData = useQuery(api.pdf.queries.getPdf, {
    pdfId: jobId,
  });

  // Get the file URL
  const fileUrl = useQuery(
    api.files.queries.getFileDownloadUrl,
    pdfData?.fileId ? { fileId: pdfData.fileId as Id<"_storage"> } : "skip"
  );

  // Initialize state based on query results
  useEffect(() => {
    // Only initialize once all data is available
    if (
      !initialized &&
      job !== undefined &&
      jobReplicate !== undefined &&
      openaiGeminiResults !== undefined &&
      openaiReplicateResults !== undefined
    ) {
      console.log("Initializing with data:", {
        geminiStatus: openaiGeminiResults?.[0]?.cleaningStatus,
        replicateStatus: openaiReplicateResults?.[0]?.cleaningStatus,
        geminiOcr: job?.[0]?.ocrStatus,
        replicateOcr: jobReplicate?.[0]?.ocrStatus,
      });

      // Set initial Gemini state
      if (openaiGeminiResults?.[0]?.cleaningStatus === "completed") {
        setGeminiStep("completed");
        setG(openaiGeminiResults[0].cleanedText || "");
        console.log("Setting initial Gemini step to completed");
      } else if (job?.[0]?.ocrStatus === "completed") {
        setGeminiStep("streaming");
      } else if (job?.[0]?.ocrStatus === "processing") {
        setGeminiStep("processing");
      } else {
        setGeminiStep("uploaded");
      }

      // Set initial Replicate state
      if (openaiReplicateResults?.[0]?.cleaningStatus === "completed") {
        setR(openaiReplicateResults[0].cleanedText || "");
        setReplicateStep("completed");
        console.log("Setting initial Replicate step to completed");
      } else if (jobReplicate?.[0]?.ocrStatus === "completed") {
        setReplicateStep("streaming");
      } else if (jobReplicate?.[0]?.ocrStatus === "processing") {
        setReplicateStep("processing");
      } else {
        setReplicateStep("uploaded");
      }

      setInitialized(true);
      console.log("Initialization complete");
    }
  }, [
    job,
    jobReplicate,
    openaiGeminiResults,
    openaiReplicateResults,
    initialized,
  ]);

  const gText = gBuf || "Ÿäÿ™ŸÖ ÿßŸÑÿ¢ŸÜ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖŸÑŸÅ Ÿàÿ™ÿ≠ŸàŸäŸÑŸá ÿ•ŸÑŸâ ŸÜÿµ";
  const rText = rBuf || "Ÿäÿ™ŸÖ ÿßŸÑÿ¢ŸÜ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖŸÑŸÅ Ÿàÿ™ÿ≠ŸàŸäŸÑŸá ÿ•ŸÑŸâ ŸÜÿµ";

  // Set PDF URL when file data is available
  useEffect(() => {
    if (fileUrl) {
      setPdfUrl(fileUrl);
    }
  }, [fileUrl]);

  // Handle Gemini OCR processing - only run after initialization and if not already completed
  useEffect(() => {
    if (!initialized || geminiStep === "completed") return;

    // If OCR is completed but we don't have results yet, start streaming
    if (
      job?.[0]?.ocrStatus === "completed" &&
      gBuf === "" &&
      !isLoadingGemini
    ) {
      console.log("Starting Gemini streaming process");
      setGeminiStep("streaming");
      setIsLoadingGemini(true);

      // Stream clean the results
      streamClean(jobId as string, "gemini", (chunk) => {
        setG(chunk);
        if (chunk.length > 0) {
          console.log("Gemini stream data received, setting to completed");
          setGeminiStep("completed");
        }
      })
        .catch((error) => {
          console.error("Error streaming Gemini cleanup:", error);
          setError(`Failed to process Gemini OCR: ${error.message}`);
        })
        .finally(() => {
          setIsLoadingGemini(false);
        });
    }
  }, [initialized, job, jobId, gBuf, isLoadingGemini, geminiStep]);

  // Handle Replicate OCR processing - only run after initialization and if not already completed
  useEffect(() => {
    if (!initialized || replicateStep === "completed") return;

    // If OCR is completed but we don't have results yet, start streaming
    if (
      jobReplicate?.[0]?.ocrStatus === "completed" &&
      rBuf === "" &&
      !isLoadingReplicate
    ) {
      console.log("Starting Replicate streaming process");
      setReplicateStep("streaming");
      setIsLoadingReplicate(true);

      // Stream clean the results
      streamClean(jobId as string, "replicate", (chunk) => {
        setR(chunk);
        if (chunk.length > 0) {
          console.log("Replicate stream data received, setting to completed");
          setReplicateStep("completed");
        }
      })
        .catch((error) => {
          console.error("Error streaming Replicate cleanup:", error);
          setError(`Failed to process Replicate OCR: ${error.message}`);
        })
        .finally(() => {
          setIsLoadingReplicate(false);
        });
    }
  }, [
    initialized,
    jobReplicate,
    jobId,
    rBuf,
    isLoadingReplicate,
    replicateStep,
  ]);

  // Always render with current state
  return (
    <div
      className="flex flex-col md:flex-row items-start justify-center min-h-screen p-4 overflow-y-auto"
      style={{
        backgroundImage: 'url("/background.png")',
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
      }}
    >
      {error && (
        <div className="fixed top-4 right-4 bg-red-600/90 backdrop-blur-md text-white px-4 py-2 rounded-lg shadow-lg z-50 max-w-md">
          <div className="flex items-center">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="h-6 w-6 mr-2"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
            <span>{error}</span>
          </div>
        </div>
      )}

      <div className="w-full md:w-1/2 mb-4 md:mb-0">
        <PdfPreviewSection pdfUrl={pdfUrl} />
      </div>

      <div className="w-full md:w-1/2 pl-0 md:pl-2">
        {/* Gemini OCR section */}
        <div className="mb-6">
          <GlassmorphicProgressStepper
            currentStep={geminiStep}
            modelType="gemini"
          />
          <OCRfile
            textToDisplay={gText}
            closed={true}
            hide={geminiStep !== "completed"}
          />
        </div>

        {/* Replicate OCR section */}
        <div className="mb-6">
          <GlassmorphicProgressStepper
            currentStep={replicateStep}
            modelType="replicate"
          />
          <OCRfile
            textToDisplay={rText}
            closed={false}
            hide={replicateStep !== "completed"}
          />
        </div>
      </div>
    </div>
  );
}



// File Path: src/app/pdf/[storageId]/pages/layout.tsx

/* ------------------------------------------------------------------ */
/* src/app/pdf/[storageId]/pages/layout.tsx                           */
/* ------------------------------------------------------------------ */
"use client";

import React from "react";
import { useParams } from "next/navigation";
import { PdfPageProvider } from "@/app/pdf/pages/context";
import { useQuery } from "convex/react";
import { api } from "../../../../../convex/_generated/api";
import { Id } from "../../../../../convex/_generated/dataModel";

export default function PagesLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // 1. Get the dynamic segment from the url          /pdf/[storageId]/
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const { storageId } = useParams<{ storageId: string }>();

  // 2. Load PDF meta-data to know how many pages we have
  const pdf = useQuery(api.pdf.queries.getPdf, {
    pdfId: storageId as Id<"pdfs">,
  });

  const totalPages = pdf?.pageCount ?? 0;

  // 3. Provide page-navigation context to the subtree
  return (
    <PdfPageProvider initialPage={1} totalPages={totalPages}>
      <div className="grid h-full w-full gap-4">{children}</div>
    </PdfPageProvider>
  );
}



// File Path: src/app/pdf/[storageId]/pages/page.tsx

// src/app/pdf/[storageId]/pages/page.tsx
"use client";

import { useParams } from "next/navigation";
import { useQuery } from "convex/react";
import { api } from "../../../../../convex/_generated/api";
import { Id } from "../../../../../convex/_generated/dataModel";
import PDFViewer, { PDFViewerHandle } from "@/app/components/PDFViewer";
import { PageAccordion } from "@/components/pageAccordion";
import ProgressBarOverall from "@/components/ProgressBarOverall";
import { usePdfPage } from "@/app/pdf/pages/context";
import { useRef, useEffect, useState } from "react";
import { motion } from "motion/react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton";

export default function PagesView() {
  const params = useParams();
  const storageId = params.storageId as Id<"pdfs">;
  const { page, setPage } = usePdfPage();
  const viewerRef = useRef<PDFViewerHandle>(null);
  const [isAccordionCollapsed, setIsAccordionCollapsed] = useState(false);

  // Get PDF data
  const pdf = useQuery(api.pdf.queries.getPdf, { pdfId: storageId });
  const fileUrl = useQuery(
    api.files.queries.getFileDownloadUrl,
    pdf?.fileId ? { fileId: pdf.fileId as Id<"_storage"> } : "skip"
  );

  // Get pages data for accordion
  const pages = useQuery(api.pdf.queries.getPagesByPdf, { pdfId: storageId });

  // Handle page changes from PDFViewer
  const handlePageChange = (pageNumber: number) => {
    setPage(pageNumber);
  };

  // Sync context page changes to PDFViewer
  useEffect(() => {
    if (page && viewerRef.current) {
      viewerRef.current.goToPage(page);
    }
  }, [page]);

  // Calculate proportions
  const accordionWidth = isAccordionCollapsed
    ? "w-16"
    : "w-full md:w-[65%] lg:w-[70%]";
  const pdfWidth = isAccordionCollapsed
    ? "w-full"
    : "w-full md:w-[35%] lg:w-[70%]";

  // Show skeleton loading state
  if (!pdf || !pages) {
    return (
      <div
        className="h-screen flex flex-col relative overflow-hidden"
        style={{
          backgroundImage: 'url("/background.png")',
          backgroundSize: "cover",
          backgroundPosition: "center",
          backgroundRepeat: "no-repeat",
        }}
      >
        {/* Skeleton Progress Bar */}
        <div className="sticky top-0 z-50 bg-emerald-950/80 backdrop-blur-md border-b border-emerald-800/30 p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <Skeleton className="h-6 w-40 bg-white/10" />
              <Skeleton className="h-4 w-24 bg-white/10" />
            </div>
            <Skeleton className="h-8 w-32 bg-white/10" />
          </div>
        </div>

        {/* Skeleton Main Content */}
        <div className="flex-1 flex gap-1 md:gap-2 p-2 md:p-4 overflow-hidden">
          {/* Skeleton Accordion Section */}
          <div className="w-full md:w-[65%] lg:w-[70%] relative">
            <div className="h-full bg-white/5 backdrop-blur-md rounded-xl border border-white/10 p-4 space-y-4">
              {/* Search bar skeleton */}
              <Skeleton className="h-10 w-full bg-white/10" />

              {/* Accordion items skeleton */}
              {Array.from({ length: 3 }).map((_, i) => (
                <div
                  key={i}
                  className="bg-white/5 rounded-lg border border-white/10 p-4 space-y-3"
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <Skeleton className="h-6 w-32 bg-white/10" />
                      <Skeleton className="h-4 w-4 bg-white/10 rounded-full" />
                      <Skeleton className="h-4 w-4 bg-white/10 rounded-full" />
                    </div>
                  </div>
                  <div className="space-y-3">
                    <Skeleton className="h-4 w-20 bg-white/10" />
                    <Skeleton className="h-24 w-full bg-white/10" />
                    <Skeleton className="h-4 w-20 bg-white/10" />
                    <Skeleton className="h-24 w-full bg-white/10" />
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Skeleton Divider */}
          <div className="hidden md:block w-px bg-gradient-to-t from-transparent via-emerald-500/50 to-transparent" />

          {/* Skeleton PDF Viewer Section */}
          <div className="w-full md:w-[35%] lg:w-[30%] relative">
            <div className="h-full bg-white/5 backdrop-blur-md rounded-xl border border-white/10 flex items-center justify-center">
              <div className="text-center space-y-4">
                <Skeleton className="h-96 w-full bg-white/10" />
                <Skeleton className="h-4 w-24 mx-auto bg-white/10" />
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div
      className="h-screen flex flex-col relative overflow-hidden"
      style={{
        backgroundImage: 'url("/background.png")',
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
      }}
    >
      {/* Enhanced Progress Bar */}
      <motion.div
        initial={{ y: -100, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        transition={{ duration: 0.5 }}
        className="sticky top-0 z-50 bg-emerald-950/80 backdrop-blur-md border-b border-emerald-800/30"
      >
        <div className="flex items-center justify-between p-4">
          <div className="flex items-center gap-4">
            <h1 className="text-lg font-semibold text-white">{pdf.filename}</h1>
            <span className="text-sm text-emerald-300">
              ÿµŸÅÿ≠ÿ© {page} ŸÖŸÜ {pdf.pageCount}
            </span>
          </div>
          <ProgressBarOverall pdfId={storageId} />
        </div>
      </motion.div>

      {/* Main Content Area */}
      <div className="flex-1 flex gap-1 md:gap-2 p-2 md:p-4 overflow-hidden">
        {/* Accordion Section */}
        <motion.div
          initial={{ x: -100, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          transition={{ duration: 0.3 }}
          className={`transition-all duration-300 ${accordionWidth} relative`}
        >
          <div className="h-full bg-white/5 backdrop-blur-md rounded-xl border border-white/10 overflow-hidden">
            {!isAccordionCollapsed && (
              <div className="h-full overflow-y-auto p-2 md:p-4 custom-scrollbar">
                <PageAccordion pages={pages} />
              </div>
            )}
            {/* Collapse/Expand Button */}
            <button
              onClick={() => setIsAccordionCollapsed(!isAccordionCollapsed)}
              className="absolute -right-3 top-1/2 -translate-y-1/2 bg-emerald-600/90 hover:bg-emerald-600 text-white p-2 rounded-full backdrop-blur-sm transition-colors z-10 shadow-lg"
            >
              {isAccordionCollapsed ? (
                <ChevronRight className="h-4 w-4" />
              ) : (
                <ChevronLeft className="h-4 w-4" />
              )}
            </button>
          </div>
        </motion.div>

        {/* Divider with gradient */}
        <div className="hidden md:block w-px bg-gradient-to-t from-transparent via-emerald-500/50 to-transparent" />

        {/* PDF Viewer Section */}
        <motion.div
          initial={{ x: 100, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          transition={{ duration: 0.3 }}
          className={`transition-all duration-300 ${pdfWidth} relative`}
        >
          <div className="h-full bg-white/5 backdrop-blur-md rounded-xl border border-white/10 overflow-hidden relative">
            <PDFViewer
              ref={viewerRef}
              pdfUrl={fileUrl || null}
              initialPage={1}
              onPageChange={handlePageChange}
              fitToWidth={true} // Always fit to width
              maxScale={2.5}
            />
          </div>
        </motion.div>
      </div>
    </div>
  );
}



// File Path: src/app/pdf/[storageId]/streamClean.ts

export async function streamClean(
  jobId: string, 
  src: "gemini" | "replicate", 
  onChunk: (c: string) => void,
  onError?: (error: Error) => void
): Promise<void> {
  console.log(`Starting stream cleaning for ${src} OCR of PDF ${jobId}`);
  
  try {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_CONVEX_URL_HTTP}/clean`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Origin": window.location.origin
      },
      body: JSON.stringify({ pdfId: jobId, source: src }),
    });

    if (!resp.ok) {
      const errorText = await resp.text();
      console.error(`Error from clean endpoint (${resp.status}):`, errorText);
      throw new Error(`Server error: ${resp.status} - ${errorText}`);
    }

    if (!resp.body) {
      throw new Error('Response body is null');
    }

    const reader = resp.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let fullText = "";
    let lastUpdateTime = 0;
    
    // Start with an empty update to indicate streaming has begun
    onChunk("");
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const newChunk = decoder.decode(value, { stream: true });
      fullText += newChunk;
      
      // Throttle updates to reduce UI jitter (every 100ms)
      const now = Date.now();
      if (now - lastUpdateTime > 100) {
        onChunk(fullText);
        lastUpdateTime = now;
      }
    }
    
    // Ensure final text is processed with any remaining decoder content
    const finalChunk = decoder.decode();
    if (finalChunk) {
      fullText += finalChunk;
    }
    
    // Final update
    onChunk(fullText);
    console.log(`Completed stream cleaning for ${src} OCR of PDF ${jobId}`);
  } catch (error) {
    console.error(`Stream clean error for ${src} OCR of PDF ${jobId}:`, error);
    if (onError && error instanceof Error) {
      onError(error);
    } else if (error instanceof Error) {
      throw error;
    } else {
      throw new Error(String(error));
    }
  }
}


// File Path: src/app/pdf/[storageId]/types/index.ts

import { Id } from '../../../../../convex/_generated/dataModel'

export interface GeminiOCRResult {
  ocrResults?: {
    processedAt?: number;
    confidenceScore?: number;
    extractedText?: string;
  }
}

export interface ReplicateOCRResult {
  ocrResults?: {
    processedAt?: number;
    replicateModelId?: string;
    extractedText?: string;
  }
}

export interface OpenAICleanedResult {
  processedAt?: number;
  openaiModel?: string;
  cleanedText?: string;
  originalSource?: string;
}

export interface OpenAIResults {
  ocrResults?: OpenAICleanedResult[];
}

export type PDFId = Id<"pdfs"> 


// File Path: src/app/pdf/[storageId]/utils/formatUtils.ts

/**
 * Formats a timestamp to a localized date string
 */
export const formatTimestamp = (timestamp?: number) => {
  if (!timestamp) return 'No timestamp'
  return new Date(timestamp).toLocaleString()
} 


// File Path: src/components/ConfirmationModal.tsx

"use client";

import { useRef } from 'react';

interface ConfirmationModalProps {
  isOpen: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel: () => void;
}

export default function ConfirmationModal({
  isOpen,
  title,
  message,
  onConfirm,
  onCancel
}: ConfirmationModalProps) {
  const cancelButtonRef = useRef(null);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50">
      <div className="bg-emerald-950/100 backdrop-blur-md border border-white/20 rounded-2xl p-6 max-w-md w-full mx-4 shadow-xl text-white">
        <h3 className="text-lg font-medium mb-2 text-right">{title}</h3>
        <p className="text-sm text-white/80 mb-4 text-right">{message}</p>
        
        <div className="flex justify-end space-x-3">
          <button
            type="button"
            className="px-4 py-2 text-sm font-medium bg-white/10 border border-white/30 rounded-lg hover:bg-white/20 transition-colors"
            onClick={onCancel}
            ref={cancelButtonRef}
          >
            ÿßŸÑÿ±ÿ¨Ÿàÿπ  
          </button>
          <button
            type="button"
            className="px-4 py-2 text-sm font-medium text-white bg-white/20 backdrop-blur-sm border border-white/30 rounded-lg hover:bg-white/30 transition-colors"
            onClick={onConfirm}
          >
            ÿ™ÿ£ŸÉŸäÿØ
          </button>
        </div>
      </div>
    </div>
  );
} 


// File Path: src/components/OcrStepperMini.tsx

// /components/ocr/OcrStepperMini.tsx
import { cn } from "@/lib/utils";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

type OcrStatus = "pending" | "processing" | "completed" | "failed";

interface OcrStepperMiniProps {
  provider: "gemini" | "replicate";
  status: OcrStatus;
}

const statusColors = {
  pending: "bg-muted/30",
  processing: "bg-yellow-400/80",
  completed: "bg-emerald-500/90",
  failed: "bg-destructive"
};

export default function OcrStepperMini({ provider, status }: OcrStepperMiniProps) {
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <span 
            className={cn("h-4 px-2 rounded-full", statusColors[status])}
            aria-label={`${provider} OCR status: ${status}`}
          />
        </TooltipTrigger>
        <TooltipContent>
          {provider.charAt(0).toUpperCase() + provider.slice(1)} ‚Ä¢ {status}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}


// File Path: src/components/pageAccordion.tsx

// src/components/pageAccordion.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import { cn } from "@/lib/utils";
import {
  Accordion,
  AccordionItem,
  AccordionTrigger,
  AccordionContent,
} from "@/components/ui/accordion";
import { Skeleton } from "@/components/ui/skeleton";
import OcrStepperMini from "@/components/OcrStepperMini";
import type { PdfPageInfo } from "@/app/pdf/types";
import StreamedTextBox from "@/app/pdf/StreamedTextBox";
import { usePdfPage } from "@/app/pdf/pages/context";
import { useKickClean } from "@/app/pdf/[storageId]/hooks/useKickClean";
import { motion } from "motion/react";

interface PageAccordionProps {
  pages: PdfPageInfo[];
  defaultOpen?: number | null;
  className?: string;
}

// Component that kicks the OpenAI clean-stream on mount
function PageContentWithKicks({ page }: { page: PdfPageInfo }) {
  useKickClean({ pageId: page.pageId, src: "gemini" });
  useKickClean({ pageId: page.pageId, src: "replicate" });

  return (
    <div className="space-y-4">
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.1 }}
      >
        <h4 className="mb-2 text-right text-sm font-medium text-yellow-400/50">
          ŸÖÿ∫ŸÑŸÇ ÿßŸÑŸÖÿµÿØÿ±
        </h4>
        <StreamedTextBox pageId={page.pageId} src="gemini" />
      </motion.div>

      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.2 }}
      >
        <h4 className="mb-2 text-right text-sm font-medium text-yellow-400/50">
          ŸÖŸÅÿ™Ÿàÿ≠ ÿßŸÑŸÖÿµÿØÿ±
        </h4>
        <StreamedTextBox pageId={page.pageId} src="replicate" />
      </motion.div>
    </div>
  );
}

export function PageAccordion({
  pages,
  defaultOpen = null,
  className,
}: PageAccordionProps) {
  const { page: currentPage, setPage } = usePdfPage();
  const [openItems, setOpenItems] = useState<string[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const scrollTimeout = useRef<NodeJS.Timeout | undefined>(undefined);
  const isAutoScrolling = useRef(false);

  // Keep track of which accordion rows are open
  useEffect(() => {
    if (pages?.length && defaultOpen !== null) {
      // If defaultOpen is specified, only open that item
      setOpenItems([defaultOpen.toString()]);
    } else if (currentPage) {
      // Start with only the current page open
      setOpenItems([currentPage.toString()]);
    }
  }, [pages, defaultOpen, currentPage]);

  // Only auto-scroll when the page changes programmatically (not by accordion click)
  useEffect(() => {
    if (!currentPage || isAutoScrolling.current) return;

    const id = currentPage.toString();

    // Always ensure current page is open
    if (!openItems.includes(id)) {
      setOpenItems((prev) => [...prev, id]);
    }

    // Auto-scroll to current page only once after page changes
    clearTimeout(scrollTimeout.current);
    scrollTimeout.current = setTimeout(() => {
      isAutoScrolling.current = true;
      const element = document.querySelector(`[data-page="${currentPage}"]`);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "center" });
      }

      // Reset auto-scrolling flag after animation
      setTimeout(() => {
        isAutoScrolling.current = false;
      }, 500);
    }, 100);

    return () => {
      clearTimeout(scrollTimeout.current);
    };
  }, [currentPage, openItems, setOpenItems]); // Only depend on currentPage, not openItems

  // Filter pages based on search
  const filteredPages = pages?.filter(
    (page) =>
      page.pageNumber.toString().includes(searchQuery) ||
      page.cleanedSnippet?.includes(searchQuery)
  );

  if (!pages) {
    return (
      <div className="space-y-2">
        {Array.from({ length: 4 }).map((_, i) => (
          <Skeleton key={i} className="h-16 w-full" />
        ))}
      </div>
    );
  }

  if (pages.length === 0) {
    return (
      <div className="py-8 text-center text-emerald-300">
        <p>ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸÅÿ≠ÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©</p>
      </div>
    );
  }

  const convertToOcrStatus = (
    status: string
  ): "pending" | "processing" | "completed" | "failed" =>
    ["pending", "processing", "completed", "failed"].includes(status)
      ? (status as "pending" | "processing" | "completed" | "failed")
      : "pending";

  // Simplified value change handler
  const handleValueChange = (values: string[]) => {
    setOpenItems(values);
  };

  // Handle clicking on page number
  const handlePageClick = (
    pageNumber: number,
    e: React.MouseEvent<HTMLSpanElement>
  ) => {
    e.stopPropagation();
    e.preventDefault();
    setPage(pageNumber);
  };

  return (
    <div
      dir="rtl"
      className={cn(
        "h-full overflow-y-auto space-y-3 custom-scrollbar",
        className
      )}
    >
      {/* Search Bar */}
      <div className="bg-emerald-950/80 backdrop-blur-md rounded-lg p-3 mb-2">
        <input
          type="text"
          placeholder="ÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑÿµŸÅÿ≠ÿßÿ™..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="w-full px-3 py-2 text-sm text-white bg-white/10 border border-white/20 rounded-md placeholder:text-white/50 focus:outline-none focus:ring-2 focus:ring-emerald-500/50"
        />
      </div>

      <Accordion
        type="multiple"
        value={openItems}
        onValueChange={handleValueChange}
        className="space-y-2"
      >
        {filteredPages.map((page) => (
          <AccordionItem
            key={page.pageId}
            value={page.pageNumber.toString()}
            data-page={page.pageNumber}
            className="backdrop-blur-sm rounded-lg border border-white/10 overflow-hidden"
          >
            <AccordionTrigger className="flex items-center justify-between gap-3 p-4 hover:bg-white/10 transition-colors">
              <div className="flex items-center gap-3">
                {/* Use a span with onClick instead of nested button */}
                <span
                  onClick={(e) => handlePageClick(page.pageNumber, e)}
                  className={cn(
                    "text-lg font-medium transition-colors cursor-pointer hover:text-emerald-300",
                    currentPage === page.pageNumber
                      ? "text-emerald-400"
                      : "text-white"
                  )}
                >
                  ÿµŸÅÿ≠ÿ© {page.pageNumber}
                </span>
                {currentPage === page.pageNumber && (
                  <span className="h-2 w-2 bg-emerald-400 rounded-full animate-pulse" />
                )}

                {/* Status Indicators - Gemini (first) and Replicate (second) */}
                <div className="flex items-center gap-1.5">
                  <OcrStepperMini
                    provider="gemini"
                    status={convertToOcrStatus(page.geminiStatus)}
                  />
                  <OcrStepperMini
                    provider="replicate"
                    status={convertToOcrStatus(page.replicateStatus)}
                  />
                </div>
              </div>
            </AccordionTrigger>

            <AccordionContent className="px-4 pb-4 pt-0">
              <PageContentWithKicks page={page} />
            </AccordionContent>
          </AccordionItem>
        ))}
      </Accordion>
    </div>
  );
}



// File Path: src/components/PDFDropzone.tsx

"use client";

import { useCallback, useRef, useState } from "react";
import { useDropzone } from 'react-dropzone';
import { countPdfPages } from "@/utils/pdfUtils";

interface PDFDropzoneProps {
  selectedPDF: File | null;
  setSelectedPDF: (file: File | null) => void;
  pageCount: number | null;
  setPageCount: (count: number | null) => void;
  isLoading: boolean;
  setIsLoading: (isLoading: boolean) => void;
}

export default function PDFDropzone({
  selectedPDF,
  setSelectedPDF,
  pageCount,
  setPageCount,
  isLoading,
  setIsLoading
}: PDFDropzoneProps) {
  const PDFInput = useRef<HTMLInputElement>(null);
  const [dropzoneError, setDropzoneError] = useState<string | null>(null);

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setSelectedPDF(file);
      try {
        const count = await countPdfPages(file, setIsLoading);
        setPageCount(count);
      } catch (error) {
        console.error("Error counting pages:", error);
        setPageCount(0);
      }
    }
  };

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    setDropzoneError(null);
    if (acceptedFiles.length > 0) {
      const file = acceptedFiles[0];
      if (file.type !== 'application/pdf') {
        setDropzoneError('Only PDF files are allowed');
        return;
      }
      
      setSelectedPDF(file);
      try {
        const count = await countPdfPages(file, setIsLoading);
        setPageCount(count);
        if (PDFInput.current) {
          // Create a DataTransfer object to set the files
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(file);
          PDFInput.current.files = dataTransfer.files;
        }
      } catch (error) {
        console.error("Error counting pages:", error);
        setPageCount(0);
      }
    }
  }, [setSelectedPDF, setPageCount, setIsLoading]);

  const { getRootProps, getInputProps, isDragActive, isDragReject } = useDropzone({
    onDrop,
    accept: {
      'application/pdf': ['.pdf']
    },
    maxFiles: 1,
    multiple: false
  });

  return (
    <div 
      {...getRootProps()} 
      className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors
        ${isDragActive ? 'border-blue-400 bg-blue-400/10' : 'border-white/30 hover:border-white/50'}
        ${isDragReject ? 'border-red-400 bg-red-400/10' : ''}
        ${selectedPDF ? 'bg-green-400/10 border-green-400' : ''}
      `}
    >
      <input {...getInputProps()} />
      <input
        type="file"
        accept="application/pdf"
        ref={PDFInput}
        onChange={handleFileSelect}
        className="hidden"
      />
      
      <div className="flex flex-col items-center justify-center space-y-2">
        <svg 
          className={`w-12 h-12 mb-3 ${selectedPDF ? 'text-green-400' : 'text-white/70'}`} 
          fill="none" 
          stroke="currentColor" 
          viewBox="0 0 24 24" 
          xmlns="http://www.w3.org/2000/svg"
        >
          <path 
            strokeLinecap="round" 
            strokeLinejoin="round" 
            strokeWidth="2" 
            d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          />
        </svg>
        
        {selectedPDF ? (
          <div>
            <p className="text-sm font-medium text-green-400">
              Selected: {selectedPDF.name}
            </p>
            {pageCount !== null && (
              <p className="text-xs text-white/70 mt-1">({pageCount} pages)</p>
            )}
          </div>
        ) : (
          <div>
            <p className="font-medium text-white">
              {isDragActive ? 'Drop the PDF here' : 'Drag & drop a PDF file here'}
            </p>
            <p className="text-xs text-white/70 mt-1">
              or click to select a file
            </p>
            <p className="text-xs font-medium text-white/70 mt-2">
              Only PDF files are accepted
            </p>
          </div>
        )}
        
        {isLoading && (
          <div className="mt-2 flex items-center justify-center">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
            <span className="ml-2 text-sm text-white/80">Ÿäÿ™ŸÖ ÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅ...</span>
          </div>
        )}
        
        {dropzoneError && (
          <p className="text-sm font-medium text-red-400 mt-2">{dropzoneError}</p>
        )}
      </div>
    </div>
  );
} 


// File Path: src/components/pdfProvider.tsx




// File Path: src/components/ProgressBarOverall.tsx

// src/components/ProgressBarOverall.tsx
"use client";

import { useQuery } from "convex/react";
import { api } from "../../convex/_generated/api";
import { Id } from "../../convex/_generated/dataModel";
import { usePageStream } from "@/store/pageStreams";
import { motion } from "motion/react";

interface ProgressBarOverallProps {
  pdfId: Id<"pdfs">;
}

export default function ProgressBarOverall({ pdfId }: ProgressBarOverallProps) {
  const pages = useQuery(api.pdf.queries.getPagesByPdf, { pdfId });
  const { chunks } = usePageStream();

  if (!pages) return null;

  // Count pages with any cleaned content in the store
  const totalPages = pages.length;
  const completedPages = pages.filter((page) => {
    const geminiKey = `${page.pageId}_gemini` as keyof typeof chunks;
    const replicateKey = `${page.pageId}_replicate` as keyof typeof chunks;
    return chunks[geminiKey]?.length > 0 || chunks[replicateKey]?.length > 0;
  }).length;

  const progress = totalPages > 0 ? (completedPages / totalPages) * 100 : 0;

  return (
    <motion.div
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      className="flex items-center gap-3"
    >
      <div className="flex flex-col items-end gap-1">
        <div className="text-xs text-emerald-300">
          {completedPages} / {totalPages} ÿµŸÅÿ≠ÿ©
        </div>
        <div className="w-32 h-2 bg-emerald-900/30 rounded-full overflow-hidden">
          <motion.div
            initial={{ width: 0 }}
            animate={{ width: `${progress}%` }}
            transition={{ duration: 0.5, ease: "easeOut" }}
            className="h-full bg-emerald-400 rounded-full"
          />
        </div>
      </div>
      <div className="text-sm font-medium text-emerald-300">
        {Math.round(progress)}%
      </div>
    </motion.div>
  );
}



// File Path: src/components/QRCodePopup.tsx

import { useState, useEffect, useCallback } from "react";
import Image from "next/image";
import { X } from "lucide-react";

interface QRCodePopupProps {
  onClose: () => void;
}

export default function QRCodePopup({ onClose }: QRCodePopupProps) {
  const [isClosing, setIsClosing] = useState(false);

  // Handle QR popup closing animation
  const handleClose = useCallback(() => {
    setIsClosing(true);
    setTimeout(() => {
      onClose();
      setIsClosing(false);
    }, 500); // Match animation duration
  }, [onClose]);

  // Close on escape key
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        handleClose();
      }
    };

    window.addEventListener("keydown", handleEscKey);
    return () => window.removeEventListener("keydown", handleEscKey);
  }, [handleClose]);

  return (
    <div
      className={`hidden lg:block fixed bottom-6 left-6 bg-white/10 backdrop-blur-md shadow-lg rounded-xl p-4 border border-white/20 ${
        isClosing ? "animate-slide-out-left" : "animate-slide-in-left"
      }`}
    >
      <button
        className="absolute top-1 right-1 text-white/80 hover:text-white"
        onClick={handleClose}
        aria-label="Close QR code popup"
      >
        <X size={20} />
      </button>
      <div className="text-white text-sm mb-2 text-center pt-2">
        ÿßŸÖÿ≥ÿ≠ ÿßŸÑÿ±ŸÖÿ≤ ŸÑŸÑŸàÿµŸàŸÑ ŸÑŸÑÿ™ÿ∑ÿ®ŸäŸÇ
      </div>
      <div className="w-32 h-32 relative">
        <Image
          src="/qr-code.png"
          alt="QR Code"
          fill
          className="object-contain ml-2"
        />
      </div>
    </div>
  );
}



// File Path: src/components/ui/accordion.tsx

"use client";

import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDownIcon } from "lucide-react";

import { cn } from "@/lib/utils";

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />;
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  );
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  );
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  );
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };



// File Path: src/components/ui/alert-dialog.tsx

"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



// File Path: src/components/ui/alert.tsx

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }



// File Path: src/components/ui/badge.tsx

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



// File Path: src/components/ui/button.tsx

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



// File Path: src/components/ui/skeleton.tsx

import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



// File Path: src/components/ui/text-generate-effect.tsx

"use client";
import { useEffect } from "react";
import { motion, stagger, useAnimate } from "motion/react";
import { cn } from "@/lib/utils";

export const TextGenerateEffect = ({
  words,
  className,
  filter = true,
  duration = 0.5,
}: {
  words: string;
  className?: string;
  filter?: boolean;
  duration?: number;
}) => {
  const [scope, animate] = useAnimate();
  const wordsArray = words.split(" ");
  useEffect(() => {
    animate(
      "span",
      {
        opacity: 1,
        filter: filter ? "blur(0px)" : "none",
      },
      {
        duration: duration ? duration : 1,
        delay: stagger(0.2),
      }
    );
  }, [animate, duration, filter]);

  const renderWords = () => {
    return (
      <motion.div ref={scope}>
        {wordsArray.map((word, idx) => {
          return (
            <motion.span
              key={word + idx}
              className="dark:text-white text-white text-4xl text-center opacity-0 mb-10"
              style={{
                filter: filter ? "blur(10px)" : "none",
              }}
            >
              {word}{" "}
            </motion.span>
          );
        })}
      </motion.div>
    );
  };

  return (
    <div className={cn("font-bold", className)}>
      <div className="mt-4">
        <div className=" dark:text-white text-white text-2xl leading-snug tracking-wide text-center mb-10">
          {renderWords()}
        </div>
      </div>
    </div>
  );
};



// File Path: src/components/ui/textarea.tsx

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder focus-visible:border-ring focus-visible:ring-ring/100 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



// File Path: src/components/ui/toggle.tsx

"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }



// File Path: src/components/ui/tooltip.tsx

"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



// File Path: src/components/UploadButton.tsx

"use client";

import { useState } from "react";
import ConfirmationModal from "./ConfirmationModal";

interface UploadButtonProps {
  selectedPDF: File | null;
  isLoading: boolean;
  onSubmit?: () => void;
}

export default function UploadButton({ 
  selectedPDF, 
  isLoading, 
  onSubmit 
}: UploadButtonProps) {
  const [showConfirmModal, setShowConfirmModal] = useState(false);
  
  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    if (selectedPDF && !isLoading) {
      setShowConfirmModal(true);
    }
  };
  
  const handleConfirm = () => {
    setShowConfirmModal(false);
    if (onSubmit) {
      onSubmit();
    }
  };
  
  const handleCancel = () => {
    setShowConfirmModal(false);
  };
  
  return (
    <>
      <button
        type="button"
        className="px-4 py-2 bg-white/20 backdrop-blur-sm text-white rounded-lg hover:bg-white/30 disabled:opacity-50 disabled:cursor-not-allowed w-full transition-colors border border-white/30 mt-7"
        disabled={selectedPDF === null || isLoading}
        onClick={handleClick}
      >
        {isLoading ? 'Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...' : 'ÿßÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅ'}
      </button>
      
      <ConfirmationModal
        isOpen={showConfirmModal}
        title="ÿ™ÿ≠ÿ∞Ÿäÿ±"
        message="ÿ£ÿ™ÿπŸáÿØ ÿ®ÿπÿØŸÖ ÿ±ŸÅÿπ ÿ£Ÿà ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿ£Ÿä ŸÖŸÑŸÅÿßÿ™ ŸÇÿØ ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ≥ÿ±ŸäŸá ŸàŸÇÿØ ÿ™ÿπÿ±ÿ∂ Ÿáÿ∞Ÿá ÿßŸÑŸàÿ≤ÿßÿ±ÿ© ŸÑÿ£ÿ∂ÿ±ÿßÿ±ÿß ŸÉÿ®Ÿäÿ±ÿ©"
        onConfirm={handleConfirm}
        onCancel={handleCancel}
      />
    </>
  );
} 


// File Path: src/lib/ocrColors.ts

// lib/ocrColors.ts
type OcrStatus = "pending" | "processing" | "completed" | "failed";

export function getStatusColor(status: OcrStatus): string {
  const statusColors = {
    pending: "bg-muted/30", // gray 300
    processing: "bg-yellow-400/80",
    completed: "bg-emerald-500/90",
    failed: "bg-destructive", // rose-600
  };
  
  return statusColors[status] || statusColors.pending;
}


// File Path: src/lib/utils.ts

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



// File Path: src/services/pdfService.ts

/**
 * Upload a PDF file using the provided mutation functions
 */
export const uploadPDF = async (
  file: File,
  pageCount: number,
  generateUploadUrl: () => Promise<string>,
  sendPDF: (args: { fileId: string, filename: string, fileSize: number, pageCount: number }) => Promise<string>,
  processWithMultipleOcrMutation: (args: { pdfId: string }) => Promise<void>
) => {
  // Step 1: Get a short-lived upload URL
  const postUrl = await generateUploadUrl();
  
  // Step 2: POST the file to the URL
  const result = await fetch(postUrl, {
    method: "POST",
    headers: { "Content-Type": file.type },
    body: file,
  });
  
  const { storageId } = await result.json();
  
  // Step 3: Save the newly allocated storage id and page count to the database
  const pdfId = await sendPDF({ 
    fileId: storageId, 
    filename: file.name, 
    fileSize: file.size,
    pageCount: pageCount || 0
  });

  // Step 4: Process the PDF with OCR
  await processWithMultipleOcrMutation({ pdfId: pdfId });

  return pdfId;
}; 


// File Path: src/store/pageStreams.ts

// src/store/pageStreams.ts
import { create } from "zustand";
import { Id } from "../../convex/_generated/dataModel";

type PageStreamKey = `${Id<"pages">}_${"gemini" | "replicate"}`;
type InFlightKey = `${Id<"pages">}_${"gemini" | "replicate"}`;

interface PageStreamState {
  chunks: Record<PageStreamKey, string>;
  inFlight: Set<InFlightKey>;
  setChunk: (key: PageStreamKey, txt: string) => void;
  markInFlight: (key: InFlightKey) => void;
  clearInFlight: (key: InFlightKey) => void;
}

export const usePageStream = create<PageStreamState>((set) => ({
  chunks: {},
  inFlight: new Set(),
  setChunk: (key, txt) =>
    set((state) => ({ chunks: { ...state.chunks, [key]: txt } })),
  markInFlight: (key) =>
    set((state) => ({ inFlight: new Set([...state.inFlight, key]) })),
  clearInFlight: (key) =>
    set((state) => {
      const newSet = new Set(state.inFlight);
      newSet.delete(key);
      return { inFlight: newSet };
    }),
}));

// Handy selector for getting text by pageId and source
export const selectChunk = (pageId: Id<"pages">, src: "gemini" | "replicate") =>
  (state: PageStreamState) => state.chunks[`${pageId}_${src}`] ?? "";


// File Path: src/utils/citationParser.ts

// src/utils/citationParser.ts - Utility to parse citations from text

export interface ParsedCitation {
  filename: string;
  pageNumber: number | null;
  fullCitation: string;
}

export interface CitationSummary {
  [filename: string]: {
    pages: Set<number>;
    totalReferences: number;
  };
}

/**
 * Parse citations from bot response text
 * Supports format: (filename.pdf, p. 5) or (filename.pdf)
 */
export function parseCitations(text: string): ParsedCitation[] {
  // Regex to match citations in the format (filename.pdf, p. 5) or (filename.pdf)
  const citationRegex = /\(([^,)]+\.pdf)(?:,\s*p\.\s*(\d+))?\)/g;
  const citations: ParsedCitation[] = [];

  let match;
  while ((match = citationRegex.exec(text)) !== null) {
    const filename = match[1];
    const pageNumber = match[2] ? parseInt(match[2], 10) : null;
    const fullCitation = match[0];

    citations.push({
      filename,
      pageNumber,
      fullCitation,
    });
  }

  return citations;
}

/**
 * Group citations by filename with page references
 */
export function groupCitationsByFile(
  citations: ParsedCitation[]
): CitationSummary {
  const summary: CitationSummary = {};

  citations.forEach((citation) => {
    if (!summary[citation.filename]) {
      summary[citation.filename] = {
        pages: new Set<number>(),
        totalReferences: 0,
      };
    }

    if (citation.pageNumber !== null) {
      summary[citation.filename].pages.add(citation.pageNumber);
    }
    summary[citation.filename].totalReferences++;
  });

  return summary;
}

/**
 * Extract all unique page numbers from citations
 */
export function extractPageNumbers(citations: ParsedCitation[]): number[] {
  const pages = new Set<number>();

  citations.forEach((citation) => {
    if (citation.pageNumber !== null) {
      pages.add(citation.pageNumber);
    }
  });

  return Array.from(pages).sort((a, b) => a - b);
}

/**
 * Find which files are referenced in the text
 */
export function findReferencedFiles(text: string): string[] {
  const citations = parseCitations(text);
  const files = new Set<string>();

  citations.forEach((citation) => {
    files.add(citation.filename);
  });

  return Array.from(files);
}

/**
 * Create a citation link that can be used in UI
 */
export function createCitationLink(citation: ParsedCitation): string {
  if (citation.pageNumber !== null) {
    return `${citation.filename}#page=${citation.pageNumber}`;
  }
  return citation.filename;
}

/**
 * Format citation for display
 */
export function formatCitation(
  filename: string,
  pageNumber?: number | null
): string {
  if (pageNumber !== null && pageNumber !== undefined) {
    return `(${filename}, p. ${pageNumber})`;
  }
  return `(${filename})`;
}

/**
 * Validate if a citation is properly formatted
 */
export function isValidCitation(citation: string): boolean {
  const citationRegex = /\(([^,)]+\.pdf)(?:,\s*p\.\s*(\d+))?\)/;
  return citationRegex.test(citation);
}

/**
 * Convert citations to clickable links in HTML/markdown
 */
export function makeCitationsClickable(text: string): string {
  const citations = parseCitations(text);
  let result = text;

  // Sort citations by position in text (reverse order to avoid index issues)
  citations.reverse().forEach((citation) => {
    const clickableLink = `<button 
      class="text-emerald-400 hover:text-emerald-300 underline cursor-pointer"
      onclick="citationClick('${citation.filename}', ${citation.pageNumber})"
    >
      ${citation.fullCitation}
    </button>`;

    result = result.replace(citation.fullCitation, clickableLink);
  });

  return result;
}

/**
 * Get statistics about citations in text
 */
export function getCitationStats(text: string) {
  const citations = parseCitations(text);
  const summary = groupCitationsByFile(citations);

  return {
    totalCitations: citations.length,
    uniqueFiles: Object.keys(summary).length,
    filesWithPages: Object.values(summary).filter((s) => s.pages.size > 0)
      .length,
    mostReferencedFile:
      Object.entries(summary).sort(
        ([, a], [, b]) => b.totalReferences - a.totalReferences
      )[0]?.[0] || null,
    totalUniquePages: Object.values(summary).reduce(
      (sum, s) => sum + s.pages.size,
      0
    ),
  };
}



// File Path: src/utils/pdfUtils.ts

/**
 * Count the number of pages in a PDF file using regex
 */
export const countPdfPages = (
  file: File,
  setIsLoading: (isLoading: boolean) => void
): Promise<number> => {
  return new Promise((resolve) => {
    setIsLoading(true);
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const content = e.target?.result as ArrayBuffer;
        const bytes = new Uint8Array(content);
        let text = "";
        
        // Convert binary data to string
        for (let i = 0; i < bytes.length; i++) {
          text += String.fromCharCode(bytes[i]);
        }
        
        // Use regex to find page count patterns
        const pageCountRegex = /\/Count\s+(\d+)/;
        const match = text.match(pageCountRegex);
        setIsLoading(false);
        if (match && match[1]) {
          const count = parseInt(match[1], 10);
          resolve(count);
        } else {
          console.warn("Could not determine page count, defaulting to 1 page");
          resolve(1);
        }
      } catch (error) {
        setIsLoading(false);
        console.error("Error counting PDF pages:", error);
        resolve(1);
      }
    };
    
    reader.onerror = (error) => {
      setIsLoading(false);
      console.error("Error reading PDF file:", error);
      resolve(1);
    };
    
    reader.readAsArrayBuffer(file);
  });
}; 


// File Path: tailwind.config.ts

import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: ["class"],
  future: {
    // Future configuration options can go here
  },
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [],
} satisfies Config;

export default config;



// File Path: tsconfig.json

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


